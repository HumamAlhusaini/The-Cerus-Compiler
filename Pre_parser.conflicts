
** Conflict (shift/reduce) in state 832.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACE list(inner_attr) list(statement)

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            block_expression 
                            LBRACE list(inner_attr) option(statements) RBRACE 
                                                    statements 
                                                    list(statement) exprs_without_block 
                                                                    operator_expression 
                                                                    expression QUESTION 
                                                                    exprs_with_block 
                                                                    (?)

** In state 832, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 832, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (reduce/reduce) in state 826.
** Tokens involved: STAR OR MINUS LT LPAREN LBRACK DOTDOTEQ DOTDOT AND
** The following explanations concentrate on token STAR.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACE list(inner_attr) exprs_with_block

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            block_expression 
                            LBRACE list(inner_attr) option(statements) RBRACE 
                                                    statements 
                                                    (?)

** In state 826, looking ahead at STAR, reducing production
** expression -> exprs_with_block
** is permitted because of the following sub-derivation:

exprs_without_block 
operator_expression 
expression STAR expression // lookahead token appears
exprs_with_block . 

** In state 826, looking ahead at STAR, reducing production
** option(SEMI) ->
** is permitted because of the following sub-derivation:

list(statement) 
statement list(statement) // lookahead token appears because list(statement) can begin with STAR
expression_statement // lookahead token is inherited
exprs_with_block option(SEMI) // lookahead token is inherited
                 . 

** Conflict (shift/reduce) in state 813.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACE list(inner_attr) list(outer_attr) LET pattern_no_top_alt COLON typ EQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            block_expression 
                            LBRACE list(inner_attr) option(statements) RBRACE 
                                                    statements 
                                                    list(statement) 
                                                    statement list(statement) 
                                                    let_statement 
                                                    list(outer_attr) LET pattern_no_top_alt COLON typ option(let_expr) SEMI 
                                                                                                      let_expr 
                                                                                                      EQ expression option(else_expr) 
                                                                                                         exprs_with_block 
                                                                                                         (?)

** In state 813, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 813, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 809.
** Tokens involved: RAW_IDENT IDENT
** The following explanations concentrate on token RAW_IDENT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACE list(inner_attr) list(outer_attr) LET

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            block_expression 
                            LBRACE list(inner_attr) option(statements) RBRACE 
                                                    statements 
                                                    list(statement) 
                                                    statement list(statement) 
                                                    let_statement 
                                                    list(outer_attr) LET pattern_no_top_alt COLON typ option(let_expr) SEMI 
                                                                         no_range_pattern 
                                                                         (?)

** In state 809, looking ahead at RAW_IDENT, shifting is permitted
** because of the following sub-derivation:

identifier_pattern 
ident option(pat_at) 
. RAW_IDENT 

** In state 809, looking ahead at RAW_IDENT, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

struct_pattern 
path_in_expression LBRACK option(struct_pattern_elements) RBRACK 
option(PATHSEP) separated_nonempty_list(PATHSEP,path_expr_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,path_expr_segment) can begin with RAW_IDENT
. 

** Conflict (shift/reduce) in state 786.
** Token involved: POUND
** This state is reached from program after reading:

list(outer_attr) MOD ident LBRACE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
                 unsafe_module 
                 safe_module 
                 (?)

** In state 786, looking ahead at POUND, shifting is permitted
** because of the following sub-derivation:

MOD ident LBRACE list(inner_attr) items RBRACE 
                 inner_attr list(inner_attr) 
                 . POUND NOT LBRACK attr RBRACK 

** In state 786, looking ahead at POUND, reducing production
** list(inner_attr) ->
** is permitted because of the following sub-derivation:

MOD ident LBRACE list(inner_attr) items RBRACE // lookahead token appears because items can begin with POUND
                 . 

** Conflict (shift/reduce) in state 780.
** Token involved: POUND
** This state is reached from program after reading:

list(outer_attr) UNSAFE MOD ident LBRACE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
                 unsafe_module 
                 (?)

** In state 780, looking ahead at POUND, shifting is permitted
** because of the following sub-derivation:

UNSAFE MOD ident LBRACE list(inner_attr) items RBRACE 
                        inner_attr list(inner_attr) 
                        . POUND NOT LBRACK attr RBRACK 

** In state 780, looking ahead at POUND, reducing production
** list(inner_attr) ->
** is permitted because of the following sub-derivation:

UNSAFE MOD ident LBRACE list(inner_attr) items RBRACE // lookahead token appears because items can begin with POUND
                        . 

** Conflict (shift/reduce) in state 764.
** Tokens involved: SUPER SELFVALUE RAW_IDENT IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token SUPER.
** This state is reached from program after reading:

list(outer_attr) USE simple_path_special LBRACE use_tree COMMA

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
                 use_declaration 
                 USE use_tree SEMI 
                     simple_path_special LBRACE use_trees RBRACE 
                                                nonempty_separated_or_terminated_list(COMMA,use_tree) 
                                                nonempty_list(terminated(use_tree,COMMA)) 
                                                use_tree COMMA nonempty_list(terminated(use_tree,COMMA)) 
                                                               use_tree COMMA 
                                                               (?)

** In state 764, looking ahead at SUPER, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

simple_path as_id_or_underscore 
option(PATHSEP) separated_nonempty_list(PATHSEP,simple_path_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,simple_path_segment) can begin with SUPER
. 

** In state 764, looking ahead at SUPER, shifting is permitted
** because of the following sub-derivation:

simple_path_special STAR 
nonempty_list(terminated(simple_path_segment,PATHSEP)) 
simple_path_segment PATHSEP 
. SUPER 

** Conflict (shift/reduce) in state 760.
** Tokens involved: SUPER SELFVALUE RAW_IDENT IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token SUPER.
** This state is reached from program after reading:

list(outer_attr) USE simple_path_special LBRACE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
                 use_declaration 
                 USE use_tree SEMI 
                     simple_path_special LBRACE use_trees RBRACE 
                                                nonempty_separated_or_terminated_list(COMMA,use_tree) 
                                                nonempty_list(terminated(use_tree,COMMA)) 
                                                use_tree COMMA 
                                                (?)

** In state 760, looking ahead at SUPER, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

simple_path as_id_or_underscore 
option(PATHSEP) separated_nonempty_list(PATHSEP,simple_path_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,simple_path_segment) can begin with SUPER
. 

** In state 760, looking ahead at SUPER, shifting is permitted
** because of the following sub-derivation:

simple_path_special STAR 
nonempty_list(terminated(simple_path_segment,PATHSEP)) 
simple_path_segment PATHSEP 
. SUPER 

** Conflict (shift/reduce) in state 751.
** Tokens involved: SUPER SELFVALUE RAW_IDENT IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token SUPER.
** This state is reached from program after reading:

list(outer_attr) USE PATHSEP

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
                 use_declaration 
                 USE use_tree SEMI 
                     (?)

** In state 751, looking ahead at SUPER, reducing production
** option(PATHSEP) -> PATHSEP
** is permitted because of the following sub-derivation:

simple_path as_id_or_underscore 
option(PATHSEP) separated_nonempty_list(PATHSEP,simple_path_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,simple_path_segment) can begin with SUPER
PATHSEP . 

** In state 751, looking ahead at SUPER, shifting is permitted
** because of the following sub-derivation:

simple_path_special STAR 
PATHSEP nonempty_list(terminated(simple_path_segment,PATHSEP)) 
        simple_path_segment PATHSEP 
        . SUPER 

** Conflict (shift/reduce) in state 750.
** Tokens involved: SUPER SELFVALUE RAW_IDENT IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token SUPER.
** This state is reached from program after reading:

list(outer_attr) USE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
                 use_declaration 
                 USE use_tree SEMI 
                     (?)

** In state 750, looking ahead at SUPER, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

simple_path as_id_or_underscore 
option(PATHSEP) separated_nonempty_list(PATHSEP,simple_path_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,simple_path_segment) can begin with SUPER
. 

** In state 750, looking ahead at SUPER, shifting is permitted
** because of the following sub-derivation:

simple_path_special STAR 
nonempty_list(terminated(simple_path_segment,PATHSEP)) 
simple_path_segment PATHSEP 
. SUPER 

** Conflict (shift/reduce) in state 747.
** Tokens involved: UNSAFE POUND
** The following explanations concentrate on token POUND.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACE list(inner_attr) outer_attr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            block_expression 
                            LBRACE list(inner_attr) option(statements) RBRACE 
                                                    statements 
                                                    (?)

** In state 747, looking ahead at POUND, reducing production
** nonempty_list(outer_attr) -> outer_attr
** is permitted because of the following sub-derivation:

exprs_without_block 
operator_expression 
expression QUESTION 
nonempty_list(outer_attr) exprs_without_block // lookahead token appears because exprs_without_block can begin with POUND
outer_attr . 

** In state 747, looking ahead at POUND, shifting is permitted
** because of the following sub-derivation:

list(statement) 
statement list(statement) 
item 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
           outer_attr list(outer_attr) 
           . POUND LBRACK attr RBRACK 

** Conflict (shift/reduce/reduce) in state 746.
** Tokens involved: WHILE UNSAFE UNDERSCORE TRUE SUPER STRING_LIT STAR SELFVALUE SELFTYPE RETURN RAW_STRING_LIT RAW_MUT RAW_IDENT RAW_C_STRING RAW_CONST RAW_BYTE_STRING POUND PATHSEP OR NOT MOVE MINUS MATCH LT LPAREN LOOP LIFETIME_OR_LABEL LBRACK LBRACE INT_LIT IF IDENT FOR FLOAT_LIT FALSE DOTDOTEQ DOTDOT DOLLAR_CRATE C_STRING CRATE CONTINUE CONST CHAR_LIT BYTE_STRING BYTE BREAK ASYNC AND AMPMUT
** The following explanations concentrate on token LBRACE.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACE list(inner_attr) statement

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            block_expression 
                            LBRACE list(inner_attr) option(statements) RBRACE 
                                                    statements 
                                                    (?)

** In state 746, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

list(statement) 
statement list(statement) 
          statement list(statement) 
          expression_statement 
          exprs_with_block option(SEMI) 
          block_expression 
          . LBRACE list(inner_attr) option(statements) RBRACE 

** In state 746, looking ahead at LBRACE, reducing production
** list(statement) ->
** is permitted because of the following sub-derivation:

list(statement) exprs_without_block // lookahead token appears because exprs_without_block can begin with LBRACE
statement list(statement) // lookahead token is inherited
          . 

** In state 746, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

list(statement) 
statement list(statement) 
          statement list(statement) 
          expression_statement 
          exprs_with_block option(SEMI) 
          loop_expression 
          option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
          . 

** Conflict (shift/reduce) in state 744.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ STAR expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 744, looking ahead at XOREQ, reducing production
** operator_expression -> STAR expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
STAR expression . 

** In state 744, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

STAR expression 
     exprs_without_block 
     operator_expression 
     expression . XOREQ expression 

** Conflict (shift/reduce) in state 742.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ RAW_MUT expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 742, looking ahead at XOREQ, reducing production
** operator_expression -> RAW_MUT expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
RAW_MUT expression . 

** In state 742, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

RAW_MUT expression 
        exprs_without_block 
        operator_expression 
        expression . XOREQ expression 

** Conflict (shift/reduce) in state 741.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ RAW_CONST expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 741, looking ahead at XOREQ, reducing production
** operator_expression -> RAW_CONST expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
RAW_CONST expression . 

** In state 741, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

RAW_CONST expression 
          exprs_without_block 
          operator_expression 
          expression . XOREQ expression 

** Conflict (shift/reduce) in state 711.
** Tokens involved: SUPER SELFVALUE RAW_IDENT IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token SUPER.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT qualified_path_type path_ident_segment LT generic_arg COMMA

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               qualified_path_in_type 
                               qualified_path_type separated_nonempty_list(PATHSEP,type_path_segment) 
                                                   type_path_segment 
                                                   path_ident_segment type_path_seg_body 
                                                                      generic_args 
                                                                      LT separated_or_terminated_list(COMMA,generic_arg) GT 
                                                                         list(terminated(generic_arg,COMMA)) 
                                                                         generic_arg COMMA list(terminated(generic_arg,COMMA)) 
                                                                                           generic_arg COMMA list(terminated(generic_arg,COMMA)) 
                                                                                           (?)

** In state 711, looking ahead at SUPER, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

typ 
type_no_bounds 
type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,type_path_segment) can begin with SUPER
. 

** In state 711, looking ahead at SUPER, shifting is permitted
** because of the following sub-derivation:

generic_args_const 
simple_path_segment 
. SUPER 

** Conflict (reduce/reduce) in state 704.
** Tokens involved: GT COMMA
** The following explanations concentrate on token GT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT qualified_path_type path_ident_segment LT ident option(generic_args) EQ type_param_bounds

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               qualified_path_in_type 
                               qualified_path_type separated_nonempty_list(PATHSEP,type_path_segment) 
                                                   type_path_segment 
                                                   path_ident_segment type_path_seg_body 
                                                                      generic_args 
                                                                      LT separated_or_terminated_list(COMMA,generic_arg) GT // lookahead token appears
                                                                         loption(separated_nonempty_list(COMMA,generic_arg)) // lookahead token is inherited
                                                                         separated_nonempty_list(COMMA,generic_arg) // lookahead token is inherited
                                                                         generic_arg // lookahead token is inherited
                                                                         (?)

** In state 704, looking ahead at GT, reducing production
** generic_args_bounds -> ident option(generic_args) EQ type_param_bounds
** is permitted because of the following sub-derivation:

generic_args_bounds // lookahead token is inherited
ident option(generic_args) EQ type_param_bounds . 

** In state 704, looking ahead at GT, reducing production
** trait_object_type -> type_param_bounds
** is permitted because of the following sub-derivation:

generic_args_binding // lookahead token is inherited
ident option(generic_args) EQ typ // lookahead token is inherited
                              trait_object_type // lookahead token is inherited
                              type_param_bounds . 

** Conflict (reduce/reduce) in state 700.
** Tokens involved: GT COMMA
** The following explanations concentrate on token GT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT qualified_path_type path_ident_segment LT lifetime

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               qualified_path_in_type 
                               qualified_path_type separated_nonempty_list(PATHSEP,type_path_segment) 
                                                   type_path_segment 
                                                   path_ident_segment type_path_seg_body 
                                                                      generic_args 
                                                                      LT separated_or_terminated_list(COMMA,generic_arg) GT // lookahead token appears
                                                                         loption(separated_nonempty_list(COMMA,generic_arg)) // lookahead token is inherited
                                                                         separated_nonempty_list(COMMA,generic_arg) // lookahead token is inherited
                                                                         generic_arg // lookahead token is inherited
                                                                         (?)

** In state 700, looking ahead at GT, reducing production
** generic_arg -> lifetime
** is permitted because of the following sub-derivation:

lifetime . 

** In state 700, looking ahead at GT, reducing production
** type_param_bound -> lifetime
** is permitted because of the following sub-derivation:

typ // lookahead token is inherited
trait_object_type // lookahead token is inherited
type_param_bounds // lookahead token is inherited
nonempty_separated_or_terminated_list(PLUS,type_param_bound) // lookahead token is inherited
separated_nonempty_list(PLUS,type_param_bound) // lookahead token is inherited
type_param_bound // lookahead token is inherited
lifetime . 

** Conflict (shift/reduce) in state 680.
** Token involved: RPAREN
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT LPAREN trait_bound_body

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               (?)

** In state 680, looking ahead at RPAREN, reducing production
** trait_bound -> trait_bound_body
** is permitted because of the following sub-derivation:

LPAREN typ RPAREN // lookahead token appears
       type_no_bounds // lookahead token is inherited
       trait_bound // lookahead token is inherited
       trait_bound_body . 

** In state 680, looking ahead at RPAREN, shifting is permitted
** because of the following sub-derivation:

trait_bound 
LPAREN trait_bound_body . RPAREN 

** Conflict (shift/reduce) in state 674.
** Token involved: RPAREN
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT LPAREN typ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               (?)

** In state 674, looking ahead at RPAREN, reducing production
** separated_nonempty_list(COMMA,typ) -> typ
** is permitted because of the following sub-derivation:

tuple_type 
LPAREN separated_or_terminated_list(COMMA,typ) RPAREN // lookahead token appears
       loption(separated_nonempty_list(COMMA,typ)) // lookahead token is inherited
       separated_nonempty_list(COMMA,typ) // lookahead token is inherited
       typ . 

** In state 674, looking ahead at RPAREN, shifting is permitted
** because of the following sub-derivation:

LPAREN typ . RPAREN 

** Conflict (shift/reduce) in state 670.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ NOT expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 670, looking ahead at XOREQ, reducing production
** operator_expression -> NOT expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
NOT expression . 

** In state 670, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

NOT expression 
    exprs_without_block 
    operator_expression 
    expression . XOREQ expression 

** Conflict (shift/reduce) in state 668.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ MINUS expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 668, looking ahead at XOREQ, reducing production
** operator_expression -> MINUS expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
MINUS expression . 

** In state 668, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

MINUS expression 
      exprs_without_block 
      operator_expression 
      expression . XOREQ expression 

** Conflict (shift/reduce) in state 666.
** Token involved: POUND
** This state is reached from program after reading:

list(outer_attr) MOD ident LBRACE inner_attr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
                 unsafe_module 
                 safe_module 
                 (?)

** In state 666, looking ahead at POUND, shifting is permitted
** because of the following sub-derivation:

MOD ident LBRACE list(inner_attr) items RBRACE 
                 inner_attr list(inner_attr) 
                            inner_attr list(inner_attr) 
                            . POUND NOT LBRACK attr RBRACK 

** In state 666, looking ahead at POUND, reducing production
** list(inner_attr) ->
** is permitted because of the following sub-derivation:

MOD ident LBRACE list(inner_attr) items RBRACE // lookahead token appears because items can begin with POUND
                 inner_attr list(inner_attr) // lookahead token is inherited
                            . 

** Conflict (shift/reduce) in state 664.
** Tokens involved: POUND OR
** The following explanations concentrate on token POUND.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ MATCH scrutinee LBRACE list(inner_attr) first_arms

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            match_expression 
                            MATCH scrutinee LBRACE list(inner_attr) option(match_arms) RBRACE 
                                                                    match_arms 
                                                                    (?)

** In state 664, looking ahead at POUND, reducing production
** list(first_arms) ->
** is permitted because of the following sub-derivation:

list(first_arms) match_arm FATARROW expression option(COMMA) // lookahead token appears because match_arm can begin with POUND
first_arms list(first_arms) // lookahead token is inherited
           . 

** In state 664, looking ahead at POUND, shifting is permitted
** because of the following sub-derivation:

list(first_arms) match_arm FATARROW expression option(COMMA) 
first_arms list(first_arms) 
           first_arms list(first_arms) 
           match_arm FATARROW block_or_not 
           list(outer_attr) pattern option(match_arm_guard) 
           outer_attr list(outer_attr) 
           . POUND LBRACK attr RBRACK 

** Conflict (shift/reduce) in state 661.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ MATCH scrutinee LBRACE list(inner_attr) list(first_arms) match_arm FATARROW

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            match_expression 
                            MATCH scrutinee LBRACE list(inner_attr) option(match_arms) RBRACE 
                                                                    match_arms 
                                                                    list(first_arms) match_arm FATARROW expression option(COMMA) 
                                                                                                        exprs_with_block 
                                                                                                        (?)

** In state 661, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 661, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 655.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ MATCH scrutinee LBRACE list(inner_attr) list(outer_attr) pattern IF

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            match_expression 
                            MATCH scrutinee LBRACE list(inner_attr) option(match_arms) RBRACE 
                                                                    match_arms 
                                                                    list(first_arms) match_arm FATARROW expression option(COMMA) 
                                                                    first_arms list(first_arms) 
                                                                    match_arm FATARROW block_or_not 
                                                                    list(outer_attr) pattern option(match_arm_guard) 
                                                                                             match_arm_guard 
                                                                                             IF expression 
                                                                                                exprs_with_block 
                                                                                                (?)

** In state 655, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 655, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (reduce/reduce) in state 649.
** Token involved: OR
** This state is reached from program after reading:

POUND LBRACK simple_path EQ MATCH scrutinee LBRACE list(inner_attr) match_arm FATARROW exprs_with_block

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            match_expression 
                            MATCH scrutinee LBRACE list(inner_attr) option(match_arms) RBRACE 
                                                                    match_arms 
                                                                    list(first_arms) match_arm FATARROW expression option(COMMA) 
                                                                    (?)

** In state 649, looking ahead at OR, reducing production
** expression -> exprs_with_block
** is permitted because of the following sub-derivation:

first_arms list(first_arms) 
match_arm FATARROW block_or_not 
                   exprs_without_block COMMA 
                   operator_expression 
                   expression OR expression // lookahead token appears
                   exprs_with_block . 

** In state 649, looking ahead at OR, reducing production
** option(COMMA) ->
** is permitted because of the following sub-derivation:

first_arms list(first_arms) // lookahead token appears because list(first_arms) can begin with OR
match_arm FATARROW block_or_not // lookahead token is inherited
                   exprs_with_block option(COMMA) // lookahead token is inherited
                                    . 

** Conflict (shift/reduce) in state 646.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ MATCH scrutinee LBRACE list(inner_attr) match_arm FATARROW

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            match_expression 
                            MATCH scrutinee LBRACE list(inner_attr) option(match_arms) RBRACE 
                                                                    match_arms 
                                                                    list(first_arms) match_arm FATARROW expression option(COMMA) 
                                                                    first_arms list(first_arms) 
                                                                    match_arm FATARROW block_or_not 
                                                                                       exprs_with_block option(COMMA) 
                                                                                       (?)

** In state 646, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 646, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 641.
** Tokens involved: POUND OR
** The following explanations concentrate on token POUND.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ MATCH scrutinee LBRACE list(inner_attr)

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            match_expression 
                            MATCH scrutinee LBRACE list(inner_attr) option(match_arms) RBRACE 
                                                                    match_arms 
                                                                    (?)

** In state 641, looking ahead at POUND, reducing production
** list(first_arms) ->
** is permitted because of the following sub-derivation:

list(first_arms) match_arm FATARROW expression option(COMMA) // lookahead token appears because match_arm can begin with POUND
. 

** In state 641, looking ahead at POUND, shifting is permitted
** because of the following sub-derivation:

list(first_arms) match_arm FATARROW expression option(COMMA) 
first_arms list(first_arms) 
match_arm FATARROW block_or_not 
list(outer_attr) pattern option(match_arm_guard) 
outer_attr list(outer_attr) 
. POUND LBRACK attr RBRACK 

** Conflict (shift/reduce) in state 640.
** Token involved: POUND
** This state is reached from program after reading:

POUND LBRACK simple_path EQ MATCH scrutinee LBRACE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            match_expression 
                            (?)

** In state 640, looking ahead at POUND, shifting is permitted
** because of the following sub-derivation:

MATCH scrutinee LBRACE list(inner_attr) option(match_arms) RBRACE 
                       inner_attr list(inner_attr) 
                       . POUND NOT LBRACK attr RBRACK 

** In state 640, looking ahead at POUND, reducing production
** list(inner_attr) ->
** is permitted because of the following sub-derivation:

MATCH scrutinee LBRACE list(inner_attr) option(match_arms) RBRACE // lookahead token appears because option(match_arms) can begin with POUND
                       . 

** Conflict (shift/reduce) in state 637.
** Token involved: RPAREN
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LPAREN expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            (?)

** In state 637, looking ahead at RPAREN, shifting is permitted
** because of the following sub-derivation:

grouped_expression 
LPAREN expression . RPAREN 

** In state 637, looking ahead at RPAREN, reducing production
** separated_nonempty_list(COMMA,expression) -> expression
** is permitted because of the following sub-derivation:

tuple_expression 
LPAREN option(tuple_elements) RPAREN // lookahead token appears
       tuple_elements // lookahead token is inherited
       separated_nonempty_list(COMMA,expression) // lookahead token is inherited
       expression . 

** Conflict (shift/reduce) in state 628.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACK expression COMMA

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            array_expression 
                            LBRACK array_elements RBRACK 
                                   nonempty_separated_or_terminated_list(COMMA,expression) 
                                   nonempty_list(terminated(expression,COMMA)) 
                                   expression COMMA nonempty_list(terminated(expression,COMMA)) 
                                                    expression COMMA 
                                                    exprs_with_block 
                                                    (?)

** In state 628, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 628, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 626.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACK expression SEMI

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            array_expression 
                            LBRACK array_elements RBRACK 
                                   expression SEMI expression 
                                                   exprs_with_block 
                                                   (?)

** In state 626, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 626, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 620.
** Token involved: ELSE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACE list(inner_attr) list(outer_attr) LET pattern_no_top_alt COLON typ EQ IF expression block_expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            block_expression 
                            LBRACE list(inner_attr) option(statements) RBRACE 
                                                    statements 
                                                    list(statement) 
                                                    statement list(statement) 
                                                    let_statement 
                                                    list(outer_attr) LET pattern_no_top_alt COLON typ option(let_expr) SEMI 
                                                                                                      let_expr 
                                                                                                      (?)

** In state 620, looking ahead at ELSE, shifting is permitted
** because of the following sub-derivation:

EQ expression option(else_expr) 
   exprs_with_block 
   if_expression 
   IF expression block_expression else_opt 
                                  . ELSE block_expression 

** In state 620, looking ahead at ELSE, reducing production
** else_opt ->
** is permitted because of the following sub-derivation:

EQ expression option(else_expr) // lookahead token appears because option(else_expr) can begin with ELSE
   exprs_with_block // lookahead token is inherited
   if_expression // lookahead token is inherited
   IF expression block_expression else_opt // lookahead token is inherited
                                  . 

** Conflict (shift/reduce) in state 613.
** Token involved: ELSE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACE list(inner_attr) list(outer_attr) LET pattern_no_top_alt COLON typ EQ IF LET pattern EQ expression block_expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            block_expression 
                            LBRACE list(inner_attr) option(statements) RBRACE 
                                                    statements 
                                                    list(statement) 
                                                    statement list(statement) 
                                                    let_statement 
                                                    list(outer_attr) LET pattern_no_top_alt COLON typ option(let_expr) SEMI 
                                                                                                      let_expr 
                                                                                                      (?)

** In state 613, looking ahead at ELSE, shifting is permitted
** because of the following sub-derivation:

EQ expression option(else_expr) 
   exprs_with_block 
   if_let_expression 
   IF LET pattern EQ expression block_expression else_opt 
                                                 . ELSE block_expression 

** In state 613, looking ahead at ELSE, reducing production
** else_opt ->
** is permitted because of the following sub-derivation:

EQ expression option(else_expr) // lookahead token appears because option(else_expr) can begin with ELSE
   exprs_with_block // lookahead token is inherited
   if_let_expression // lookahead token is inherited
   IF LET pattern EQ expression block_expression else_opt // lookahead token is inherited
                                                 . 

** Conflict (shift/reduce) in state 611.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ DOTDOTEQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            (?)

** In state 611, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

range_expression 
DOTDOTEQ expression 
         exprs_without_block 
         operator_expression 
         expression . XOREQ expression 

** In state 611, looking ahead at XOREQ, reducing production
** range_expression -> DOTDOTEQ expression
** is permitted because of the following sub-derivation:

operator_expression 
expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
range_expression // lookahead token is inherited
DOTDOTEQ expression . 

** Conflict (shift/reduce) in state 610.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ DOTDOT expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            (?)

** In state 610, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

range_expression 
DOTDOT expression 
       exprs_without_block 
       operator_expression 
       expression . XOREQ expression 

** In state 610, looking ahead at XOREQ, reducing production
** range_expression -> DOTDOT expression
** is permitted because of the following sub-derivation:

operator_expression 
expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
range_expression // lookahead token is inherited
DOTDOT expression . 

** Conflict (shift/reduce) in state 609.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ RETURN expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            (?)

** In state 609, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

return_expression 
RETURN option(expression) 
       expression 
       exprs_without_block 
       operator_expression 
       expression . XOREQ expression 

** In state 609, looking ahead at XOREQ, reducing production
** option(expression) -> expression
** is permitted because of the following sub-derivation:

operator_expression 
expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
return_expression // lookahead token is inherited
RETURN option(expression) // lookahead token is inherited
       expression . 

** Conflict (shift/reduce) in state 604.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ ASYNC MOVE OR option(closure_params) OR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            ASYNC MOVE OR option(closure_params) OR expr_or_typ_block 
                                                                    expression 
                                                                    exprs_with_block 
                                                                    (?)

** In state 604, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 604, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 590.
** Tokens involved: RAW_IDENT IDENT
** The following explanations concentrate on token RAW_IDENT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR list(outer_attr)

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                               closure_params 
                               nonempty_separated_or_terminated_list(COMMA,closure_param) 
                               nonempty_list(terminated(closure_param,COMMA)) 
                               closure_param COMMA 
                               list(outer_attr) pattern_no_top_alt option(typ_opt) 
                                                no_range_pattern 
                                                (?)

** In state 590, looking ahead at RAW_IDENT, shifting is permitted
** because of the following sub-derivation:

identifier_pattern 
ident option(pat_at) 
. RAW_IDENT 

** In state 590, looking ahead at RAW_IDENT, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

struct_pattern 
path_in_expression LBRACK option(struct_pattern_elements) RBRACK 
option(PATHSEP) separated_nonempty_list(PATHSEP,path_expr_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,path_expr_segment) can begin with RAW_IDENT
. 

** Conflict (shift/reduce) in state 586.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR option(closure_params) OR expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            (?)

** In state 586, looking ahead at XOREQ, reducing production
** expr_or_typ_block -> expression
** is permitted because of the following sub-derivation:

operator_expression 
expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
closure_expression // lookahead token is inherited
OR option(closure_params) OR expr_or_typ_block // lookahead token is inherited
                             expression . 

** In state 586, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

closure_expression 
OR option(closure_params) OR expr_or_typ_block 
                             expression 
                             exprs_without_block 
                             operator_expression 
                             expression . XOREQ expression 

** Conflict (shift/reduce) in state 585.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ AND expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 585, looking ahead at XOREQ, reducing production
** operator_expression -> AND expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
AND expression . 

** In state 585, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

AND expression 
    exprs_without_block 
    operator_expression 
    expression . XOREQ expression 

** Conflict (shift/reduce) in state 584.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ AMPMUT expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 584, looking ahead at XOREQ, reducing production
** operator_expression -> AMPMUT expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
AMPMUT expression . 

** In state 584, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

AMPMUT expression 
       exprs_without_block 
       operator_expression 
       expression . XOREQ expression 

** Conflict (shift/reduce) in state 580.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ path_in_expression LBRACE loption(separated_nonempty_list(COMMA,struct_expr_field)) COMMA DOTDOT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            struct_expression 
                            path_in_expression struct_expr_body 
                                               LBRACE struct_expr_fields RBRACE 
                                                      loption(separated_nonempty_list(COMMA,struct_expr_field)) COMMA struct_base 
                                                                                                                      DOTDOT expression 
                                                                                                                             exprs_with_block 
                                                                                                                             (?)

** In state 580, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 580, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 573.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ path_in_expression LBRACE list(outer_attr) ident COLON

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            struct_expression 
                            path_in_expression struct_expr_body 
                                               LBRACE struct_expr_fields RBRACE 
                                                      loption(separated_nonempty_list(COMMA,struct_expr_field)) COMMA struct_base 
                                                      separated_nonempty_list(COMMA,struct_expr_field) 
                                                      struct_expr_field 
                                                      list(outer_attr) ident COLON expression 
                                                                                   exprs_with_block 
                                                                                   (?)

** In state 573, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 573, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 567.
** Token involved: COMMA
** This state is reached from program after reading:

POUND LBRACK simple_path EQ path_in_expression LBRACE struct_expr_field

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            struct_expression 
                            path_in_expression struct_expr_body 
                                               LBRACE struct_expr_fields RBRACE 
                                                      (?)

** In state 567, looking ahead at COMMA, shifting is permitted
** because of the following sub-derivation:

nonempty_separated_or_terminated_list(COMMA,struct_expr_field) 
nonempty_list(terminated(struct_expr_field,COMMA)) 
struct_expr_field . COMMA 

** In state 567, looking ahead at COMMA, reducing production
** separated_nonempty_list(COMMA,struct_expr_field) -> struct_expr_field
** is permitted because of the following sub-derivation:

loption(separated_nonempty_list(COMMA,struct_expr_field)) COMMA struct_base // lookahead token appears
separated_nonempty_list(COMMA,struct_expr_field) // lookahead token is inherited
struct_expr_field . 

** Conflict (shift/reduce) in state 562.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ path_in_expression LBRACE DOTDOT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            struct_expression 
                            path_in_expression struct_expr_body 
                                               LBRACE DOTDOT expression RBRACE 
                                                             exprs_with_block 
                                                             (?)

** In state 562, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 562, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 548.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ option(loop_label) FOR pattern IN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            loop_expression 
                            option(loop_label) loop_switch 
                                               iterator_loop_expression 
                                               FOR pattern IN expression block_expression 
                                                              exprs_with_block 
                                                              (?)

** In state 548, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 548, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 537.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LPAREN expression COMMA

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            tuple_expression 
                            LPAREN option(tuple_elements) RPAREN 
                                   tuple_elements 
                                   separated_nonempty_list(COMMA,expression) 
                                   expression COMMA separated_nonempty_list(COMMA,expression) 
                                                    expression 
                                                    exprs_with_block 
                                                    (?)

** In state 537, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 537, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 536.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression AND expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 536, looking ahead at XOREQ, reducing production
** operator_expression -> expression AND expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression AND expression . 

** In state 536, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression AND expression 
               exprs_without_block 
               operator_expression 
               expression . XOREQ expression 

** Conflict (shift/reduce) in state 535.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression AND

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression AND expression 
                                           exprs_with_block 
                                           (?)

** In state 535, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 535, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 534.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression ANDAND expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 534, looking ahead at XOREQ, reducing production
** operator_expression -> expression ANDAND expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression ANDAND expression . 

** In state 534, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression ANDAND expression 
                  exprs_without_block 
                  operator_expression 
                  expression . XOREQ expression 

** Conflict (shift/reduce) in state 533.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression ANDAND

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression ANDAND expression 
                                              exprs_with_block 
                                              (?)

** In state 533, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 533, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 532.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression ANDEQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 532, looking ahead at XOREQ, reducing production
** operator_expression -> expression ANDEQ expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression ANDEQ expression . 

** In state 532, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression ANDEQ expression 
                 exprs_without_block 
                 operator_expression 
                 expression . XOREQ expression 

** Conflict (shift/reduce) in state 531.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression ANDEQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression ANDEQ expression 
                                             exprs_with_block 
                                             (?)

** In state 531, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 531, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (reduce/reduce) in state 528.
** Token involved: LPAREN
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression DOT ident

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            (?)

** In state 528, looking ahead at LPAREN, reducing production
** field_expression -> expression DOT ident
** is permitted because of the following sub-derivation:

call_expression 
expression LPAREN call_params RPAREN // lookahead token appears
exprs_without_block // lookahead token is inherited
field_expression // lookahead token is inherited
expression DOT ident . 

** In state 528, looking ahead at LPAREN, reducing production
** path_ident_segment -> ident
** is permitted because of the following sub-derivation:

method_call_expression 
expression DOT path_expr_segment LPAREN call_params RPAREN // lookahead token appears
               path_ident_segment option(path_genarg) // lookahead token is inherited because option(path_genarg) can vanish
               ident . 

** Conflict (shift/reduce) in state 516.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression DOT path_expr_segment LPAREN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            method_call_expression 
                            expression DOT path_expr_segment LPAREN call_params RPAREN 
                                                                    loption(separated_nonempty_list(COMMA,expression)) 
                                                                    separated_nonempty_list(COMMA,expression) 
                                                                    expression 
                                                                    exprs_with_block 
                                                                    (?)

** In state 516, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 516, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 511.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression DOTDOT expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            (?)

** In state 511, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

range_expression 
expression DOTDOT expression 
                  exprs_without_block 
                  operator_expression 
                  expression . XOREQ expression 

** In state 511, looking ahead at XOREQ, reducing production
** range_expression -> expression DOTDOT expression
** is permitted because of the following sub-derivation:

operator_expression 
expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
range_expression // lookahead token is inherited
expression DOTDOT expression . 

** Conflict (shift/reduce) in state 510.
** Tokens involved: STAR OR MINUS LT LPAREN LBRACK LBRACE DOTDOTEQ DOTDOT AND
** The following explanations concentrate on token STAR.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression DOTDOT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            (?)

** In state 510, looking ahead at STAR, shifting is permitted
** because of the following sub-derivation:

range_expression 
expression DOTDOT expression 
                  exprs_without_block 
                  operator_expression 
                  . STAR expression 

** In state 510, looking ahead at STAR, reducing production
** range_expression -> expression DOTDOT
** is permitted because of the following sub-derivation:

operator_expression 
expression STAR expression // lookahead token appears
exprs_without_block // lookahead token is inherited
range_expression // lookahead token is inherited
expression DOTDOT . 

** Conflict (shift/reduce) in state 509.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression DOTDOTEQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            (?)

** In state 509, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

range_expression 
expression DOTDOTEQ expression 
                    exprs_without_block 
                    operator_expression 
                    expression . XOREQ expression 

** In state 509, looking ahead at XOREQ, reducing production
** range_expression -> expression DOTDOTEQ expression
** is permitted because of the following sub-derivation:

operator_expression 
expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
range_expression // lookahead token is inherited
expression DOTDOTEQ expression . 

** Conflict (shift/reduce) in state 508.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression DOTDOTEQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            range_expression 
                            expression DOTDOTEQ expression 
                                                exprs_with_block 
                                                (?)

** In state 508, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 508, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 507.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression EQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 507, looking ahead at XOREQ, reducing production
** operator_expression -> expression EQ expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression EQ expression . 

** In state 507, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression EQ expression 
              exprs_without_block 
              operator_expression 
              expression . XOREQ expression 

** Conflict (shift/reduce) in state 506.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression EQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression EQ expression 
                                          exprs_with_block 
                                          (?)

** In state 506, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 506, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 505.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression EQEQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 505, looking ahead at XOREQ, reducing production
** operator_expression -> expression EQEQ expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression EQEQ expression . 

** In state 505, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression EQEQ expression 
                exprs_without_block 
                operator_expression 
                expression . XOREQ expression 

** Conflict (shift/reduce) in state 504.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression EQEQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression EQEQ expression 
                                            exprs_with_block 
                                            (?)

** In state 504, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 504, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 503.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression GE expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 503, looking ahead at XOREQ, reducing production
** operator_expression -> expression GE expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression GE expression . 

** In state 503, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression GE expression 
              exprs_without_block 
              operator_expression 
              expression . XOREQ expression 

** Conflict (shift/reduce) in state 502.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression GE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression GE expression 
                                          exprs_with_block 
                                          (?)

** In state 502, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 502, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 501.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression GT expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 501, looking ahead at XOREQ, reducing production
** operator_expression -> expression GT expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression GT expression . 

** In state 501, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression GT expression 
              exprs_without_block 
              operator_expression 
              expression . XOREQ expression 

** Conflict (shift/reduce) in state 500.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression GT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression GT expression 
                                          exprs_with_block 
                                          (?)

** In state 500, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 500, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 497.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression LBRACK

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            index_expression 
                            expression LBRACK expression RBRACK 
                                              exprs_with_block 
                                              (?)

** In state 497, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 497, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 496.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression LE expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 496, looking ahead at XOREQ, reducing production
** operator_expression -> expression LE expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression LE expression . 

** In state 496, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression LE expression 
              exprs_without_block 
              operator_expression 
              expression . XOREQ expression 

** Conflict (shift/reduce) in state 495.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression LE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression LE expression 
                                          exprs_with_block 
                                          (?)

** In state 495, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 495, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 492.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression LPAREN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            call_expression 
                            expression LPAREN call_params RPAREN 
                                              loption(separated_nonempty_list(COMMA,expression)) 
                                              separated_nonempty_list(COMMA,expression) 
                                              expression 
                                              exprs_with_block 
                                              (?)

** In state 492, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 492, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 491.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression LT expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 491, looking ahead at XOREQ, reducing production
** operator_expression -> expression LT expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression LT expression . 

** In state 491, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression LT expression 
              exprs_without_block 
              operator_expression 
              expression . XOREQ expression 

** Conflict (shift/reduce) in state 490.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression LT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression LT expression 
                                          exprs_with_block 
                                          (?)

** In state 490, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 490, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 489.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression MINUS expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 489, looking ahead at XOREQ, reducing production
** operator_expression -> expression MINUS expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression MINUS expression . 

** In state 489, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression MINUS expression 
                 exprs_without_block 
                 operator_expression 
                 expression . XOREQ expression 

** Conflict (shift/reduce) in state 488.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression MINUS

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression MINUS expression 
                                             exprs_with_block 
                                             (?)

** In state 488, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 488, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 487.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression MINUSEQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 487, looking ahead at XOREQ, reducing production
** operator_expression -> expression MINUSEQ expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression MINUSEQ expression . 

** In state 487, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression MINUSEQ expression 
                   exprs_without_block 
                   operator_expression 
                   expression . XOREQ expression 

** Conflict (shift/reduce) in state 486.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression MINUSEQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression MINUSEQ expression 
                                               exprs_with_block 
                                               (?)

** In state 486, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 486, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 485.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression NE expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 485, looking ahead at XOREQ, reducing production
** operator_expression -> expression NE expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression NE expression . 

** In state 485, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression NE expression 
              exprs_without_block 
              operator_expression 
              expression . XOREQ expression 

** Conflict (shift/reduce) in state 484.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression NE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression NE expression 
                                          exprs_with_block 
                                          (?)

** In state 484, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 484, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 483.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression OR expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 483, looking ahead at XOREQ, reducing production
** operator_expression -> expression OR expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression OR expression . 

** In state 483, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression OR expression 
              exprs_without_block 
              operator_expression 
              expression . XOREQ expression 

** Conflict (shift/reduce) in state 482.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression OR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression OR expression 
                                          exprs_with_block 
                                          (?)

** In state 482, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 482, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 481.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression OREQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 481, looking ahead at XOREQ, reducing production
** operator_expression -> expression OREQ expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression OREQ expression . 

** In state 481, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression OREQ expression 
                exprs_without_block 
                operator_expression 
                expression . XOREQ expression 

** Conflict (shift/reduce) in state 480.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression OREQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression OREQ expression 
                                            exprs_with_block 
                                            (?)

** In state 480, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 480, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 479.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression OROR expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 479, looking ahead at XOREQ, reducing production
** operator_expression -> expression OROR expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression OROR expression . 

** In state 479, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression OROR expression 
                exprs_without_block 
                operator_expression 
                expression . XOREQ expression 

** Conflict (shift/reduce) in state 478.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression OROR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression OROR expression 
                                            exprs_with_block 
                                            (?)

** In state 478, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 478, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 477.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression PERCENT expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 477, looking ahead at XOREQ, reducing production
** operator_expression -> expression PERCENT expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression PERCENT expression . 

** In state 477, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression PERCENT expression 
                   exprs_without_block 
                   operator_expression 
                   expression . XOREQ expression 

** Conflict (shift/reduce) in state 476.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression PERCENT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression PERCENT expression 
                                               exprs_with_block 
                                               (?)

** In state 476, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 476, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 475.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression PLUS expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 475, looking ahead at XOREQ, reducing production
** operator_expression -> expression PLUS expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression PLUS expression . 

** In state 475, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression PLUS expression 
                exprs_without_block 
                operator_expression 
                expression . XOREQ expression 

** Conflict (shift/reduce) in state 474.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression PLUS

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression PLUS expression 
                                            exprs_with_block 
                                            (?)

** In state 474, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 474, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 473.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression PLUSEQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 473, looking ahead at XOREQ, reducing production
** operator_expression -> expression PLUSEQ expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression PLUSEQ expression . 

** In state 473, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression PLUSEQ expression 
                  exprs_without_block 
                  operator_expression 
                  expression . XOREQ expression 

** Conflict (shift/reduce) in state 472.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression PLUSEQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression PLUSEQ expression 
                                              exprs_with_block 
                                              (?)

** In state 472, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 472, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 470.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SHL expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 470, looking ahead at XOREQ, reducing production
** operator_expression -> expression SHL expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression SHL expression . 

** In state 470, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression SHL expression 
               exprs_without_block 
               operator_expression 
               expression . XOREQ expression 

** Conflict (shift/reduce) in state 469.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SHL

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression SHL expression 
                                           exprs_with_block 
                                           (?)

** In state 469, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 469, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 468.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SHLEQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 468, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression SHLEQ expression 
                 exprs_without_block 
                 operator_expression 
                 expression . XOREQ expression 

** In state 468, looking ahead at XOREQ, reducing production
** operator_expression -> expression SHLEQ expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression SHLEQ expression . 

** Conflict (shift/reduce) in state 467.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SHLEQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression SHLEQ expression 
                                             exprs_with_block 
                                             (?)

** In state 467, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 467, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 466.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SHR expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 466, looking ahead at XOREQ, reducing production
** operator_expression -> expression SHR expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression SHR expression . 

** In state 466, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression SHR expression 
               exprs_without_block 
               operator_expression 
               expression . XOREQ expression 

** Conflict (shift/reduce) in state 465.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SHR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression SHR expression 
                                           exprs_with_block 
                                           (?)

** In state 465, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 465, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 464.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SHREQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 464, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression SHREQ expression 
                 exprs_without_block 
                 operator_expression 
                 expression . XOREQ expression 

** In state 464, looking ahead at XOREQ, reducing production
** operator_expression -> expression SHREQ expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression SHREQ expression . 

** Conflict (shift/reduce) in state 463.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SHREQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression SHREQ expression 
                                             exprs_with_block 
                                             (?)

** In state 463, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 463, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 462.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SLASH expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 462, looking ahead at XOREQ, reducing production
** operator_expression -> expression SLASH expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression SLASH expression . 

** In state 462, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression SLASH expression 
                 exprs_without_block 
                 operator_expression 
                 expression . XOREQ expression 

** Conflict (shift/reduce) in state 461.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SLASH

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression SLASH expression 
                                             exprs_with_block 
                                             (?)

** In state 461, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 461, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 460.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SLASHEQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 460, looking ahead at XOREQ, reducing production
** operator_expression -> expression SLASHEQ expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression SLASHEQ expression . 

** In state 460, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression SLASHEQ expression 
                   exprs_without_block 
                   operator_expression 
                   expression . XOREQ expression 

** Conflict (shift/reduce) in state 459.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SLASHEQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression SLASHEQ expression 
                                               exprs_with_block 
                                               (?)

** In state 459, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 459, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 458.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression STAR expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 458, looking ahead at XOREQ, reducing production
** operator_expression -> expression STAR expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression STAR expression . 

** In state 458, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression STAR expression 
                exprs_without_block 
                operator_expression 
                expression . XOREQ expression 

** Conflict (shift/reduce) in state 457.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression STAR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression STAR expression 
                                            exprs_with_block 
                                            (?)

** In state 457, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 457, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 456.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression STAREQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 456, looking ahead at XOREQ, reducing production
** operator_expression -> expression STAREQ expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression STAREQ expression . 

** In state 456, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression STAREQ expression 
                  exprs_without_block 
                  operator_expression 
                  expression . XOREQ expression 

** Conflict (shift/reduce) in state 455.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression STAREQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression STAREQ expression 
                                              exprs_with_block 
                                              (?)

** In state 455, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 455, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 454.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression XOR expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 454, looking ahead at XOREQ, reducing production
** operator_expression -> expression XOR expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression XOR expression . 

** In state 454, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression XOR expression 
               exprs_without_block 
               operator_expression 
               expression . XOREQ expression 

** Conflict (shift/reduce) in state 453.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression XOR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression XOR expression 
                                           exprs_with_block 
                                           (?)

** In state 453, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 453, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 452.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression XOREQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 452, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression XOREQ expression 
                 exprs_without_block 
                 operator_expression 
                 expression . XOREQ expression 

** In state 452, looking ahead at XOREQ, reducing production
** operator_expression -> expression XOREQ expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression XOREQ expression . 

** Conflict (shift/reduce) in state 449.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression XOREQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression XOREQ expression 
                                             exprs_with_block 
                                             (?)

** In state 449, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 449, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (reduce/reduce) in state 447.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ nonempty_list(outer_attr) exprs_with_block

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            (?)

** In state 447, looking ahead at XOREQ, reducing production
** expression -> nonempty_list(outer_attr) exprs_with_block
** is permitted because of the following sub-derivation:

exprs_without_block 
operator_expression 
expression XOREQ expression // lookahead token appears
nonempty_list(outer_attr) exprs_with_block . 

** In state 447, looking ahead at XOREQ, reducing production
** expression -> exprs_with_block
** is permitted because of the following sub-derivation:

nonempty_list(outer_attr) exprs_without_block 
                          operator_expression 
                          expression XOREQ expression // lookahead token appears
                          exprs_with_block . 

** Conflict (reduce/reduce) in state 446.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ nonempty_list(outer_attr) exprs_without_block

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            (?)

** In state 446, looking ahead at XOREQ, reducing production
** expression -> nonempty_list(outer_attr) exprs_without_block
** is permitted because of the following sub-derivation:

exprs_without_block 
operator_expression 
expression XOREQ expression // lookahead token appears
nonempty_list(outer_attr) exprs_without_block . 

** In state 446, looking ahead at XOREQ, reducing production
** expression -> exprs_without_block
** is permitted because of the following sub-derivation:

nonempty_list(outer_attr) exprs_without_block 
                          operator_expression 
                          expression XOREQ expression // lookahead token appears
                          exprs_without_block . 

** Conflict (shift/reduce) in state 435.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ nonempty_list(outer_attr)

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            nonempty_list(outer_attr) exprs_with_block 
                                                      (?)

** In state 435, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 435, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 431.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ option(loop_label) WHILE LET pattern EQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            loop_expression 
                            option(loop_label) loop_switch 
                                               predicate_pattern_loop_expression 
                                               WHILE LET pattern EQ scrutinee block_expression 
                                                                    expression 
                                                                    exprs_with_block 
                                                                    (?)

** In state 431, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 431, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 428.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ option(loop_label) WHILE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            loop_expression 
                            option(loop_label) loop_switch 
                                               predicate_loop_expression 
                                               WHILE expression block_expression 
                                                     exprs_with_block 
                                                     (?)

** In state 428, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 428, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 425.
** Token involved: POUND
** This state is reached from program after reading:

POUND LBRACK simple_path EQ outer_attr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            (?)

** In state 425, looking ahead at POUND, reducing production
** nonempty_list(outer_attr) -> outer_attr
** is permitted because of the following sub-derivation:

nonempty_list(outer_attr) exprs_without_block // lookahead token appears because exprs_without_block can begin with POUND
outer_attr . 

** In state 425, looking ahead at POUND, shifting is permitted
** because of the following sub-derivation:

nonempty_list(outer_attr) exprs_without_block 
outer_attr nonempty_list(outer_attr) 
           outer_attr 
           . POUND LBRACK attr RBRACK 

** Conflict (shift/reduce) in state 422.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ path_in_expression LPAREN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            struct_expression 
                            path_in_expression struct_expr_body 
                                               LPAREN expr_list RPAREN 
                                                      loption(separated_nonempty_list(COMMA,expression)) 
                                                      separated_nonempty_list(COMMA,expression) 
                                                      expression 
                                                      exprs_with_block 
                                                      (?)

** In state 422, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 422, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 421.
** Tokens involved: LPAREN LBRACE
** The following explanations concentrate on token LPAREN.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ path_in_expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            (?)

** In state 421, looking ahead at LPAREN, reducing production
** path_expression -> path_in_expression
** is permitted because of the following sub-derivation:

call_expression 
expression LPAREN call_params RPAREN // lookahead token appears
exprs_without_block // lookahead token is inherited
path_expression // lookahead token is inherited
path_in_expression . 

** In state 421, looking ahead at LPAREN, shifting is permitted
** because of the following sub-derivation:

struct_expression 
path_in_expression struct_expr_body 
                   . LPAREN expr_list RPAREN 

** Conflict (shift/reduce) in state 414.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ AMPMUT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            AMPMUT expression 
                                   exprs_with_block 
                                   (?)

** In state 414, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 414, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 413.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ AND

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            AND expression 
                                exprs_with_block 
                                (?)

** In state 413, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 413, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 412.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ ASYNC OR option(closure_params) OR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            ASYNC OR option(closure_params) OR expr_or_typ_block 
                                                               expression 
                                                               exprs_with_block 
                                                               (?)

** In state 412, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 412, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 408.
** Tokens involved: STAR OR MINUS LT LPAREN LBRACK LBRACE DOTDOTEQ DOTDOT AND
** The following explanations concentrate on token LBRACE.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ BREAK option(LIFETIME_OR_LABEL)

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            break_expression 
                            BREAK option(LIFETIME_OR_LABEL) option(expression) 
                                                            expression 
                                                            exprs_with_block 
                                                            (?)

** In state 408, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 408, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 407.
** Token involved: LIFETIME_OR_LABEL
** This state is reached from program after reading:

POUND LBRACK simple_path EQ BREAK

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            break_expression 
                            (?)

** In state 407, looking ahead at LIFETIME_OR_LABEL, reducing production
** option(LIFETIME_OR_LABEL) ->
** is permitted because of the following sub-derivation:

BREAK option(LIFETIME_OR_LABEL) option(expression) // lookahead token appears because option(expression) can begin with LIFETIME_OR_LABEL
      . 

** In state 407, looking ahead at LIFETIME_OR_LABEL, shifting is permitted
** because of the following sub-derivation:

BREAK option(LIFETIME_OR_LABEL) option(expression) 
      . LIFETIME_OR_LABEL 

** Conflict (shift/reduce) in state 401.
** Tokens involved: STAR OR MINUS LT LPAREN LBRACK LBRACE DOTDOTEQ DOTDOT AND
** The following explanations concentrate on token STAR.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ DOTDOT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            (?)

** In state 401, looking ahead at STAR, shifting is permitted
** because of the following sub-derivation:

range_expression 
DOTDOT expression 
       exprs_without_block 
       operator_expression 
       . STAR expression 

** In state 401, looking ahead at STAR, reducing production
** range_expression -> DOTDOT
** is permitted because of the following sub-derivation:

operator_expression 
expression STAR expression // lookahead token appears
exprs_without_block // lookahead token is inherited
range_expression // lookahead token is inherited
DOTDOT . 

** Conflict (shift/reduce) in state 400.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ DOTDOTEQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            range_expression 
                            DOTDOTEQ expression 
                                     exprs_with_block 
                                     (?)

** In state 400, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 400, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 399.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ IF LET pattern EQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            if_let_expression 
                            IF LET pattern EQ expression block_expression else_opt 
                                              exprs_with_block 
                                              (?)

** In state 399, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 399, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 396.
** Tokens involved: RAW_IDENT IDENT
** The following explanations concentrate on token RAW_IDENT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ IF LET OR pattern_no_top_alt OR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            if_let_expression 
                            IF LET pattern EQ expression block_expression else_opt 
                                   OR separated_nonempty_list(OR,pattern_no_top_alt) 
                                      pattern_no_top_alt OR separated_nonempty_list(OR,pattern_no_top_alt) 
                                                            pattern_no_top_alt 
                                                            no_range_pattern 
                                                            (?)

** In state 396, looking ahead at RAW_IDENT, shifting is permitted
** because of the following sub-derivation:

identifier_pattern 
ident option(pat_at) 
. RAW_IDENT 

** In state 396, looking ahead at RAW_IDENT, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

struct_pattern 
path_in_expression LBRACK option(struct_pattern_elements) RBRACK 
option(PATHSEP) separated_nonempty_list(PATHSEP,path_expr_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,path_expr_segment) can begin with RAW_IDENT
. 

** Conflict (reduce/reduce) in state 371.
** Tokens involved: RPAREN RBRACK OR IN IF FATARROW EQ COMMA COLON
** The following explanations concentrate on token OR.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR list(outer_attr) ANDAND MUT ident option(pat_at)

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block // lookahead token appears
                               closure_params // lookahead token is inherited
                               nonempty_separated_or_terminated_list(COMMA,closure_param) // lookahead token is inherited
                               separated_nonempty_list(COMMA,closure_param) // lookahead token is inherited
                               closure_param // lookahead token is inherited
                               list(outer_attr) pattern_no_top_alt option(typ_opt) // lookahead token is inherited because option(typ_opt) can vanish
                                                no_range_pattern // lookahead token is inherited
                                                (?)

** In state 371, looking ahead at OR, reducing production
** identifier_pattern -> MUT ident option(pat_at)
** is permitted because of the following sub-derivation:

ANDAND no_range_pattern // lookahead token is inherited
       identifier_pattern // lookahead token is inherited
       MUT ident option(pat_at) . 

** In state 371, looking ahead at OR, reducing production
** identifier_pattern -> ident option(pat_at)
** is permitted because of the following sub-derivation:

ANDAND MUT no_range_pattern // lookahead token is inherited
           identifier_pattern // lookahead token is inherited
           ident option(pat_at) . 

** Conflict (shift/reduce) in state 343.
** Token involved: COMMA
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR list(outer_attr) path_in_expression LBRACK struct_pattern_field

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                               closure_params 
                               nonempty_separated_or_terminated_list(COMMA,closure_param) 
                               nonempty_list(terminated(closure_param,COMMA)) 
                               closure_param COMMA 
                               list(outer_attr) pattern_no_top_alt option(typ_opt) 
                                                no_range_pattern 
                                                struct_pattern 
                                                path_in_expression LBRACK option(struct_pattern_elements) RBRACK 
                                                                          struct_pattern_elements 
                                                                          (?)

** In state 343, looking ahead at COMMA, reducing production
** separated_nonempty_list(COMMA,struct_pattern_field) -> struct_pattern_field
** is permitted because of the following sub-derivation:

struct_pattern_fields COMMA struct_pattern_etcetara // lookahead token appears
separated_nonempty_list(COMMA,struct_pattern_field) // lookahead token is inherited
struct_pattern_field . 

** In state 343, looking ahead at COMMA, shifting is permitted
** because of the following sub-derivation:

struct_pattern_fields COMMA struct_pattern_etcetara 
separated_nonempty_list(COMMA,struct_pattern_field) 
struct_pattern_field . COMMA separated_nonempty_list(COMMA,struct_pattern_field) 

** Conflict (reduce/reduce) in state 327.
** Token involved: RPAREN
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR list(outer_attr) path_in_expression LPAREN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                               closure_params 
                               nonempty_separated_or_terminated_list(COMMA,closure_param) 
                               nonempty_list(terminated(closure_param,COMMA)) 
                               closure_param COMMA 
                               list(outer_attr) pattern_no_top_alt option(typ_opt) 
                                                no_range_pattern 
                                                tuple_struct_pattern 
                                                path_in_expression LPAREN tuple_struct_items RPAREN // lookahead token appears
                                                                          separated_or_terminated_list(COMMA,pattern) // lookahead token is inherited
                                                                          (?)

** In state 327, looking ahead at RPAREN, reducing production
** list(terminated(pattern,COMMA)) ->
** is permitted because of the following sub-derivation:

list(terminated(pattern,COMMA)) // lookahead token is inherited
. 

** In state 327, looking ahead at RPAREN, reducing production
** loption(separated_nonempty_list(COMMA,pattern)) ->
** is permitted because of the following sub-derivation:

loption(separated_nonempty_list(COMMA,pattern)) // lookahead token is inherited
. 

** Conflict (shift/reduce) in state 322.
** Tokens involved: RAW_IDENT IDENT
** The following explanations concentrate on token RAW_IDENT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR list(outer_attr) AND MUT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                               closure_params 
                               nonempty_separated_or_terminated_list(COMMA,closure_param) 
                               nonempty_list(terminated(closure_param,COMMA)) 
                               closure_param COMMA 
                               list(outer_attr) pattern_no_top_alt option(typ_opt) 
                                                no_range_pattern 
                                                AND MUT no_range_pattern 
                                                        (?)

** In state 322, looking ahead at RAW_IDENT, shifting is permitted
** because of the following sub-derivation:

identifier_pattern 
ident option(pat_at) 
. RAW_IDENT 

** In state 322, looking ahead at RAW_IDENT, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

struct_pattern 
path_in_expression LBRACK option(struct_pattern_elements) RBRACK 
option(PATHSEP) separated_nonempty_list(PATHSEP,path_expr_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,path_expr_segment) can begin with RAW_IDENT
. 

** Conflict (shift/reduce) in state 321.
** Tokens involved: RAW_IDENT IDENT
** The following explanations concentrate on token RAW_IDENT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR list(outer_attr) AND

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                               closure_params 
                               nonempty_separated_or_terminated_list(COMMA,closure_param) 
                               nonempty_list(terminated(closure_param,COMMA)) 
                               closure_param COMMA 
                               list(outer_attr) pattern_no_top_alt option(typ_opt) 
                                                no_range_pattern 
                                                AND no_range_pattern 
                                                    (?)

** In state 321, looking ahead at RAW_IDENT, shifting is permitted
** because of the following sub-derivation:

identifier_pattern 
ident option(pat_at) 
. RAW_IDENT 

** In state 321, looking ahead at RAW_IDENT, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

struct_pattern 
path_in_expression LBRACK option(struct_pattern_elements) RBRACK 
option(PATHSEP) separated_nonempty_list(PATHSEP,path_expr_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,path_expr_segment) can begin with RAW_IDENT
. 

** Conflict (shift/reduce) in state 314.
** Tokens involved: RAW_IDENT IDENT
** The following explanations concentrate on token RAW_IDENT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR list(outer_attr) ANDAND MUT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                               closure_params 
                               nonempty_separated_or_terminated_list(COMMA,closure_param) 
                               nonempty_list(terminated(closure_param,COMMA)) 
                               closure_param COMMA 
                               list(outer_attr) pattern_no_top_alt option(typ_opt) 
                                                no_range_pattern 
                                                ANDAND MUT no_range_pattern 
                                                           (?)

** In state 314, looking ahead at RAW_IDENT, shifting is permitted
** because of the following sub-derivation:

identifier_pattern 
ident option(pat_at) 
. RAW_IDENT 

** In state 314, looking ahead at RAW_IDENT, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

struct_pattern 
path_in_expression LBRACK option(struct_pattern_elements) RBRACK 
option(PATHSEP) separated_nonempty_list(PATHSEP,path_expr_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,path_expr_segment) can begin with RAW_IDENT
. 

** Conflict (shift/reduce) in state 313.
** Tokens involved: RAW_IDENT IDENT
** The following explanations concentrate on token RAW_IDENT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR list(outer_attr) ANDAND

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                               closure_params 
                               nonempty_separated_or_terminated_list(COMMA,closure_param) 
                               nonempty_list(terminated(closure_param,COMMA)) 
                               closure_param COMMA 
                               list(outer_attr) pattern_no_top_alt option(typ_opt) 
                                                no_range_pattern 
                                                ANDAND no_range_pattern 
                                                       (?)

** In state 313, looking ahead at RAW_IDENT, shifting is permitted
** because of the following sub-derivation:

identifier_pattern 
ident option(pat_at) 
. RAW_IDENT 

** In state 313, looking ahead at RAW_IDENT, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

struct_pattern 
path_in_expression LBRACK option(struct_pattern_elements) RBRACK 
option(PATHSEP) separated_nonempty_list(PATHSEP,path_expr_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,path_expr_segment) can begin with RAW_IDENT
. 

** Conflict (shift/reduce) in state 296.
** Token involved: PATHSEP
** This state is reached from program after reading:

POUND LBRACK simple_path EQ qualified_path_type path_ident_segment

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                                                (?)

** In state 296, looking ahead at PATHSEP, reducing production
** option(path_genarg) ->
** is permitted because of the following sub-derivation:

path_expr_segment PATHSEP separated_nonempty_list(PATHSEP,path_expr_segment) // lookahead token appears
path_ident_segment option(path_genarg) // lookahead token is inherited
                   . 

** In state 296, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

path_expr_segment 
path_ident_segment option(path_genarg) 
                   path_genarg 
                   . PATHSEP generic_args 

** Conflict (shift/reduce) in state 269.
** Token involved: RPAREN
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR list(outer_attr) LPAREN pattern

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                               closure_params 
                               nonempty_separated_or_terminated_list(COMMA,closure_param) 
                               nonempty_list(terminated(closure_param,COMMA)) 
                               closure_param COMMA 
                               list(outer_attr) pattern_no_top_alt option(typ_opt) 
                                                no_range_pattern 
                                                (?)

** In state 269, looking ahead at RPAREN, shifting is permitted
** because of the following sub-derivation:

LPAREN pattern . RPAREN 

** In state 269, looking ahead at RPAREN, reducing production
** separated_nonempty_list(COMMA,pattern) -> pattern
** is permitted because of the following sub-derivation:

tuple_pattern 
LPAREN option(tuple_pattern_items) RPAREN // lookahead token appears
       tuple_pattern_items // lookahead token is inherited
       separated_nonempty_list(COMMA,pattern) // lookahead token is inherited
       pattern . 

** Conflict (shift/reduce) in state 254.
** Tokens involved: RAW_IDENT IDENT
** The following explanations concentrate on token RAW_IDENT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR list(outer_attr) ident AT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                               closure_params 
                               nonempty_separated_or_terminated_list(COMMA,closure_param) 
                               nonempty_list(terminated(closure_param,COMMA)) 
                               closure_param COMMA 
                               list(outer_attr) pattern_no_top_alt option(typ_opt) 
                                                no_range_pattern 
                                                identifier_pattern 
                                                ident option(pat_at) 
                                                      pat_at 
                                                      AT pattern_no_top_alt 
                                                         no_range_pattern 
                                                         (?)

** In state 254, looking ahead at RAW_IDENT, shifting is permitted
** because of the following sub-derivation:

identifier_pattern 
ident option(pat_at) 
. RAW_IDENT 

** In state 254, looking ahead at RAW_IDENT, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

struct_pattern 
path_in_expression LBRACK option(struct_pattern_elements) RBRACK 
option(PATHSEP) separated_nonempty_list(PATHSEP,path_expr_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,path_expr_segment) can begin with RAW_IDENT
. 

** Conflict (shift/reduce) in state 247.
** Tokens involved: RAW_IDENT IDENT
** The following explanations concentrate on token RAW_IDENT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ IF LET OR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            if_let_expression 
                            IF LET pattern EQ expression block_expression else_opt 
                                   OR separated_nonempty_list(OR,pattern_no_top_alt) 
                                      pattern_no_top_alt 
                                      no_range_pattern 
                                      (?)

** In state 247, looking ahead at RAW_IDENT, shifting is permitted
** because of the following sub-derivation:

identifier_pattern 
ident option(pat_at) 
. RAW_IDENT 

** In state 247, looking ahead at RAW_IDENT, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

struct_pattern 
path_in_expression LBRACK option(struct_pattern_elements) RBRACK 
option(PATHSEP) separated_nonempty_list(PATHSEP,path_expr_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,path_expr_segment) can begin with RAW_IDENT
. 

** Conflict (shift/reduce) in state 245.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ IF

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            if_expression 
                            IF expression block_expression else_opt 
                               exprs_with_block 
                               (?)

** In state 245, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 245, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 244.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACK

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            array_expression 
                            LBRACK array_elements RBRACK 
                                   expression SEMI expression 
                                   exprs_with_block 
                                   (?)

** In state 244, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 244, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 241.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LPAREN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            grouped_expression 
                            LPAREN expression RPAREN 
                                   exprs_with_block 
                                   (?)

** In state 241, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 241, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 240.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ MATCH

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            match_expression 
                            MATCH scrutinee LBRACE list(inner_attr) option(match_arms) RBRACE 
                                  expression 
                                  exprs_with_block 
                                  (?)

** In state 240, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 240, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 239.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ MINUS

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            MINUS expression 
                                  exprs_with_block 
                                  (?)

** In state 239, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 239, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 238.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ MOVE OR option(closure_params) OR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            MOVE OR option(closure_params) OR expr_or_typ_block 
                                                              expression 
                                                              exprs_with_block 
                                                              (?)

** In state 238, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 238, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 234.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ NOT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            NOT expression 
                                exprs_with_block 
                                (?)

** In state 234, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 234, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 233.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT LBRACK typ SEMI

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               LBRACK typ SEMI expression RBRACK 
                                               exprs_with_block 
                                               (?)

** In state 233, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 233, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (reduce/reduce) in state 231.
** Tokens involved: TRUE STRING_LIT SEMI RPAREN RBRACK RAW_STRING_LIT RAW_IDENT RAW_C_STRING RAW_BYTE_STRING OR INT_LIT IDENT GT FLOAT_LIT FALSE EQ C_STRING COMMA CHAR_LIT BYTE_STRING BYTE AS
** The following explanations concentrate on token GT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT IMPL trait_bound

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT // lookahead token appears because option(as_typath) can vanish
                               (?)

** In state 231, looking ahead at GT, reducing production
** impl_trait_type_one_bound -> IMPL trait_bound
** is permitted because of the following sub-derivation:

type_no_bounds // lookahead token is inherited
impl_trait_type_one_bound // lookahead token is inherited
IMPL trait_bound . 

** In state 231, looking ahead at GT, reducing production
** type_param_bound -> trait_bound
** is permitted because of the following sub-derivation:

impl_trait_type // lookahead token is inherited
IMPL type_param_bounds // lookahead token is inherited
     nonempty_separated_or_terminated_list(PLUS,type_param_bound) // lookahead token is inherited
     separated_nonempty_list(PLUS,type_param_bound) // lookahead token is inherited
     type_param_bound // lookahead token is inherited
     trait_bound . 

** Conflict (shift/reduce) in state 215.
** Tokens involved: GT EQ COMMA
** The following explanations concentrate on token EQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT FOR LT list(outer_attr) ident

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               trait_bound 
                               trait_bound_body 
                               for_lifetimes type_path 
                               FOR generic_params 
                                   LT separated_nonempty_list(COMMA,generic_param) GT 
                                      generic_param 
                                      list(outer_attr) type_param 
                                                       (?)

** In state 215, looking ahead at EQ, shifting is permitted
** because of the following sub-derivation:

ident option(eq_typ) 
      eq_typ 
      . EQ typ 

** In state 215, looking ahead at EQ, reducing production
** option(type_param_bounds) ->
** is permitted because of the following sub-derivation:

ident option(type_param_bounds) option(eq_typ) // lookahead token appears because option(eq_typ) can begin with EQ
      . 

** Conflict (reduce/reduce) in state 204.
** Tokens involved: GT COMMA
** The following explanations concentrate on token GT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT FOR LT list(outer_attr) lifetime COLON

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               trait_bound 
                               trait_bound_body 
                               for_lifetimes type_path 
                               FOR generic_params 
                                   LT separated_nonempty_list(COMMA,generic_param) GT // lookahead token appears
                                      generic_param // lookahead token is inherited
                                      list(outer_attr) lifetime_param // lookahead token is inherited
                                                       lifetime COLON option(lifetime_bounds) // lookahead token is inherited
                                                                      (?)

** In state 204, looking ahead at GT, reducing production
** list(terminated(lifetime,PLUS)) ->
** is permitted because of the following sub-derivation:

lifetime_bounds // lookahead token is inherited
separated_or_terminated_list(PLUS,lifetime) // lookahead token is inherited
list(terminated(lifetime,PLUS)) // lookahead token is inherited
. 

** In state 204, looking ahead at GT, reducing production
** loption(separated_nonempty_list(PLUS,lifetime)) ->
** is permitted because of the following sub-derivation:

lifetime_bounds // lookahead token is inherited
separated_or_terminated_list(PLUS,lifetime) // lookahead token is inherited
loption(separated_nonempty_list(PLUS,lifetime)) // lookahead token is inherited
. 

** In state 204, looking ahead at GT, reducing production
** option(lifetime_bounds) ->
** is permitted because of the following sub-derivation:

. 

** Conflict (reduce/reduce) in state 181.
** Tokens involved: TRUE STRING_LIT SEMI RPAREN RBRACK RAW_STRING_LIT RAW_IDENT RAW_C_STRING RAW_BYTE_STRING OR INT_LIT IDENT GT FLOAT_LIT FALSE EQ C_STRING COMMA CHAR_LIT BYTE_STRING BYTE AS
** The following explanations concentrate on token GT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT trait_bound

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT // lookahead token appears because option(as_typath) can vanish
                               (?)

** In state 181, looking ahead at GT, reducing production
** type_no_bounds -> trait_bound
** is permitted because of the following sub-derivation:

type_no_bounds // lookahead token is inherited
trait_bound . 

** In state 181, looking ahead at GT, reducing production
** type_param_bound -> trait_bound
** is permitted because of the following sub-derivation:

trait_object_type // lookahead token is inherited
type_param_bounds // lookahead token is inherited
nonempty_separated_or_terminated_list(PLUS,type_param_bound) // lookahead token is inherited
separated_nonempty_list(PLUS,type_param_bound) // lookahead token is inherited
type_param_bound // lookahead token is inherited
trait_bound . 

** Conflict (shift/reduce) in state 174.
** Tokens involved: RAW_IDENT IDENT
** The following explanations concentrate on token RAW_IDENT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT option(for_lifetimes) function_type_qualifiers FN LPAREN list(outer_attr)

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               bare_function_type 
                               option(for_lifetimes) function_type_qualifiers FN LPAREN option(function_parameters_maybe_named_variadic) RPAREN option(bare_function_return_type) 
                                                                                        function_parameters_maybe_named_variadic 
                                                                                        maybe_named_function_parameters_variadic 
                                                                                        nonempty_list(terminated(maybe_named_param,COMMA)) list(outer_attr) DOTDOTDOT 
                                                                                        maybe_named_param COMMA 
                                                                                        (?)

** In state 174, looking ahead at RAW_IDENT, shifting is permitted
** because of the following sub-derivation:

list(outer_attr) ident COLON typ 
                 . RAW_IDENT 

** In state 174, looking ahead at RAW_IDENT, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

list(outer_attr) typ 
                 type_no_bounds 
                 type_path 
                 option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,type_path_segment) can begin with RAW_IDENT
                 . 

** Conflict (shift/reduce) in state 170.
** Token involved: POUND
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT option(for_lifetimes) function_type_qualifiers FN LPAREN maybe_named_param COMMA

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               bare_function_type 
                               option(for_lifetimes) function_type_qualifiers FN LPAREN option(function_parameters_maybe_named_variadic) RPAREN option(bare_function_return_type) 
                                                                                        function_parameters_maybe_named_variadic 
                                                                                        maybe_named_function_parameters_variadic 
                                                                                        (?)

** In state 170, looking ahead at POUND, reducing production
** nonempty_list(terminated(maybe_named_param,COMMA)) -> maybe_named_param COMMA
** is permitted because of the following sub-derivation:

nonempty_list(terminated(maybe_named_param,COMMA)) list(outer_attr) DOTDOTDOT // lookahead token appears because list(outer_attr) can begin with POUND
maybe_named_param COMMA . 

** In state 170, looking ahead at POUND, shifting is permitted
** because of the following sub-derivation:

nonempty_list(terminated(maybe_named_param,COMMA)) list(outer_attr) DOTDOTDOT 
maybe_named_param COMMA nonempty_list(terminated(maybe_named_param,COMMA)) 
                        maybe_named_param COMMA 
                        list(outer_attr) ident COLON typ 
                        outer_attr list(outer_attr) 
                        . POUND LBRACK attr RBRACK 

** Conflict (reduce/reduce) in state 154.
** Token involved: RPAREN
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT option(for_lifetimes) function_type_qualifiers FN LPAREN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               bare_function_type 
                               option(for_lifetimes) function_type_qualifiers FN LPAREN option(function_parameters_maybe_named_variadic) RPAREN option(bare_function_return_type) // lookahead token appears
                                                                                        (?)

** In state 154, looking ahead at RPAREN, reducing production
** list(terminated(maybe_named_param,COMMA)) ->
** is permitted because of the following sub-derivation:

function_parameters_maybe_named_variadic // lookahead token is inherited
maybe_named_function_parameters // lookahead token is inherited
separated_or_terminated_list(COMMA,maybe_named_param) // lookahead token is inherited
list(terminated(maybe_named_param,COMMA)) // lookahead token is inherited
. 

** In state 154, looking ahead at RPAREN, reducing production
** loption(separated_nonempty_list(COMMA,maybe_named_param)) ->
** is permitted because of the following sub-derivation:

function_parameters_maybe_named_variadic // lookahead token is inherited
maybe_named_function_parameters // lookahead token is inherited
separated_or_terminated_list(COMMA,maybe_named_param) // lookahead token is inherited
loption(separated_nonempty_list(COMMA,maybe_named_param)) // lookahead token is inherited
. 

** In state 154, looking ahead at RPAREN, reducing production
** option(function_parameters_maybe_named_variadic) ->
** is permitted because of the following sub-derivation:

. 

** Conflict (reduce/reduce) in state 130.
** Tokens involved: XOREQ XOR TRUE STRING_LIT STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL SEMI RPAREN RBRACK RBRACE RAW_STRING_LIT RAW_IDENT RAW_C_STRING RAW_BYTE_STRING QUESTION PLUSEQ PLUS PERCENT PATHSEP OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK LBRACE INT_LIT IDENT GT GE FLOAT_LIT FATARROW FALSE EQEQ EQ ELSE DOTDOTEQ DOTDOT DOT C_STRING COMMA CHAR_LIT BYTE_STRING BYTE AS ANDEQ ANDAND AND
** The following explanations concentrate on token GT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT type_path

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT // lookahead token appears because option(as_typath) can vanish
                               type_no_bounds // lookahead token is inherited
                               (?)

** In state 130, looking ahead at GT, reducing production
** trait_bound_body -> type_path
** is permitted because of the following sub-derivation:

trait_bound // lookahead token is inherited
trait_bound_body // lookahead token is inherited
type_path . 

** In state 130, looking ahead at GT, reducing production
** type_no_bounds -> type_path
** is permitted because of the following sub-derivation:

type_path . 

** Conflict (reduce/reduce) in state 119.
** Tokens involved: TRUE STRING_LIT SEMI RPAREN RBRACK RAW_STRING_LIT RAW_IDENT RAW_C_STRING RAW_BYTE_STRING OR INT_LIT IDENT GT FLOAT_LIT FALSE EQ C_STRING COMMA CHAR_LIT BYTE_STRING BYTE AS
** The following explanations concentrate on token GT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT DYN trait_bound

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT // lookahead token appears because option(as_typath) can vanish
                               (?)

** In state 119, looking ahead at GT, reducing production
** type_no_bounds -> DYN trait_bound
** is permitted because of the following sub-derivation:

type_no_bounds // lookahead token is inherited
DYN trait_bound . 

** In state 119, looking ahead at GT, reducing production
** type_param_bound -> trait_bound
** is permitted because of the following sub-derivation:

trait_object_type // lookahead token is inherited
DYN type_param_bounds // lookahead token is inherited
    nonempty_separated_or_terminated_list(PLUS,type_param_bound) // lookahead token is inherited
    separated_nonempty_list(PLUS,type_param_bound) // lookahead token is inherited
    type_param_bound // lookahead token is inherited
    trait_bound . 

** Conflict (reduce/reduce) in state 111.
** Tokens involved: RAW_IDENT IDENT
** The following explanations concentrate on token RAW_IDENT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT FOR LT list(outer_attr) CONST ident COLON type_param_bound PLUS

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               trait_bound 
                               trait_bound_body 
                               for_lifetimes type_path 
                               FOR generic_params 
                                   LT separated_nonempty_list(COMMA,generic_param) GT 
                                      generic_param 
                                      list(outer_attr) const_param 
                                                       (?)

** In state 111, looking ahead at RAW_IDENT, reducing production
** nonempty_list(terminated(type_param_bound,PLUS)) -> type_param_bound PLUS
** is permitted because of the following sub-derivation:

CONST ident COLON typ option(const_param_body) // lookahead token appears because option(const_param_body) can begin with RAW_IDENT
                  trait_object_type // lookahead token is inherited
                  type_param_bounds // lookahead token is inherited
                  nonempty_separated_or_terminated_list(PLUS,type_param_bound) // lookahead token is inherited
                  nonempty_list(terminated(type_param_bound,PLUS)) // lookahead token is inherited
                  type_param_bound PLUS . 

** In state 111, looking ahead at RAW_IDENT, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

CONST ident COLON typ option(const_param_body) 
                  trait_object_type 
                  type_param_bounds 
                  nonempty_separated_or_terminated_list(PLUS,type_param_bound) 
                  nonempty_list(terminated(type_param_bound,PLUS)) 
                  type_param_bound PLUS nonempty_list(terminated(type_param_bound,PLUS)) 
                                        type_param_bound PLUS 
                                        trait_bound 
                                        trait_bound_body 
                                        type_path 
                                        option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,type_path_segment) can begin with RAW_IDENT
                                        . 

** Conflict (reduce/reduce) in state 93.
** Token involved: RPAREN
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT LPAREN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               tuple_type 
                               LPAREN separated_or_terminated_list(COMMA,typ) RPAREN // lookahead token appears
                                      (?)

** In state 93, looking ahead at RPAREN, reducing production
** list(terminated(typ,COMMA)) ->
** is permitted because of the following sub-derivation:

list(terminated(typ,COMMA)) // lookahead token is inherited
. 

** In state 93, looking ahead at RPAREN, reducing production
** loption(separated_nonempty_list(COMMA,typ)) ->
** is permitted because of the following sub-derivation:

loption(separated_nonempty_list(COMMA,typ)) // lookahead token is inherited
. 

** Conflict (shift/reduce) in state 63.
** Tokens involved: SUPER SELFVALUE RAW_IDENT IDENT GT DOLLAR_CRATE CRATE
** The following explanations concentrate on token SUPER.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT qualified_path_type path_ident_segment LT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               qualified_path_in_type 
                               qualified_path_type separated_nonempty_list(PATHSEP,type_path_segment) 
                                                   type_path_segment 
                                                   path_ident_segment type_path_seg_body 
                                                                      generic_args 
                                                                      LT separated_or_terminated_list(COMMA,generic_arg) GT 
                                                                         list(terminated(generic_arg,COMMA)) 
                                                                         generic_arg COMMA list(terminated(generic_arg,COMMA)) 
                                                                         (?)

** In state 63, looking ahead at SUPER, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

typ 
type_no_bounds 
type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,type_path_segment) can begin with SUPER
. 

** In state 63, looking ahead at SUPER, shifting is permitted
** because of the following sub-derivation:

generic_args_const 
simple_path_segment 
. SUPER 

** Conflict (shift/reduce) in state 61.
** Tokens involved: PATHSEP LT LPAREN
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT qualified_path_type path_ident_segment

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               qualified_path_in_type 
                               qualified_path_type separated_nonempty_list(PATHSEP,type_path_segment) 
                                                   (?)

** In state 61, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path_segment 
path_ident_segment type_path_seg_body 
                   . PATHSEP generic_args 

** In state 61, looking ahead at PATHSEP, reducing production
** type_path_seg_body ->
** is permitted because of the following sub-derivation:

type_path_segment PATHSEP separated_nonempty_list(PATHSEP,type_path_segment) // lookahead token appears
path_ident_segment type_path_seg_body // lookahead token is inherited
                   . 

** Conflict (shift/reduce) in state 58.
** Token involved: PATHSEP
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT qualified_path_type path_ident_segment LPAREN option(type_path_fn_inputs) RPAREN RARROW qualified_path_type type_path_segment

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               qualified_path_in_type 
                               qualified_path_type separated_nonempty_list(PATHSEP,type_path_segment) 
                                                   (?)

** In state 58, looking ahead at PATHSEP, reducing production
** separated_nonempty_list(PATHSEP,type_path_segment) -> type_path_segment
** is permitted because of the following sub-derivation:

type_path_segment PATHSEP separated_nonempty_list(PATHSEP,type_path_segment) // lookahead token appears
path_ident_segment type_path_seg_body // lookahead token is inherited
                   type_path_fn // lookahead token is inherited
                   LPAREN option(type_path_fn_inputs) RPAREN option(rarrow_no_bounds) // lookahead token is inherited
                                                             rarrow_no_bounds // lookahead token is inherited
                                                             RARROW type_no_bounds // lookahead token is inherited
                                                                    qualified_path_in_type // lookahead token is inherited
                                                                    qualified_path_type separated_nonempty_list(PATHSEP,type_path_segment) // lookahead token is inherited
                                                                                        type_path_segment . 

** In state 58, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path_segment 
path_ident_segment type_path_seg_body 
                   type_path_fn 
                   LPAREN option(type_path_fn_inputs) RPAREN option(rarrow_no_bounds) 
                                                             rarrow_no_bounds 
                                                             RARROW type_no_bounds 
                                                                    qualified_path_in_type 
                                                                    qualified_path_type separated_nonempty_list(PATHSEP,type_path_segment) 
                                                                                        type_path_segment . PATHSEP separated_nonempty_list(PATHSEP,type_path_segment) 

** Conflict (shift/reduce) in state 45.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR option(closure_params) OR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                                                         expression 
                                                         exprs_with_block 
                                                         (?)

** In state 45, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 45, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 38.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ RAW_CONST

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            RAW_CONST expression 
                                      exprs_with_block 
                                      (?)

** In state 38, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 38, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 36.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ RAW_MUT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            RAW_MUT expression 
                                    exprs_with_block 
                                    (?)

** In state 36, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 36, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 34.
** Tokens involved: STAR OR MINUS LT LPAREN LBRACK LBRACE DOTDOTEQ DOTDOT AND
** The following explanations concentrate on token LBRACE.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ RETURN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            return_expression 
                            RETURN option(expression) 
                                   expression 
                                   exprs_with_block 
                                   (?)

** In state 34, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 34, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 33.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ STAR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            STAR expression 
                                 exprs_with_block 
                                 (?)

** In state 33, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 33, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce/reduce) in state 29.
** Tokens involved: WHILE UNSAFE UNDERSCORE TRUE SUPER STRING_LIT STAR SELFVALUE SELFTYPE RETURN RBRACE RAW_STRING_LIT RAW_MUT RAW_IDENT RAW_C_STRING RAW_CONST RAW_BYTE_STRING POUND PATHSEP OR NOT MOVE MINUS MATCH LT LPAREN LOOP LIFETIME_OR_LABEL LBRACK LBRACE INT_LIT IF IDENT FOR FLOAT_LIT FALSE DOTDOTEQ DOTDOT DOLLAR_CRATE C_STRING CRATE CONTINUE CONST CHAR_LIT BYTE_STRING BYTE BREAK ASYNC AND AMPMUT
** The following explanations concentrate on token LBRACE.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACE list(inner_attr)

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            block_expression 
                            LBRACE list(inner_attr) option(statements) RBRACE 
                                                    statements 
                                                    (?)

** In state 29, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

list(statement) 
statement list(statement) 
expression_statement 
exprs_with_block option(SEMI) 
block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 29, looking ahead at LBRACE, reducing production
** list(statement) ->
** is permitted because of the following sub-derivation:

list(statement) exprs_without_block // lookahead token appears because exprs_without_block can begin with LBRACE
. 

** In state 29, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

list(statement) 
statement list(statement) 
expression_statement 
exprs_with_block option(SEMI) 
loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 8.
** Token involved: POUND
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            block_expression 
                            (?)

** In state 8, looking ahead at POUND, shifting is permitted
** because of the following sub-derivation:

LBRACE list(inner_attr) option(statements) RBRACE 
       inner_attr list(inner_attr) 
       . POUND NOT LBRACK attr RBRACK 

** In state 8, looking ahead at POUND, reducing production
** list(inner_attr) ->
** is permitted because of the following sub-derivation:

LBRACE list(inner_attr) option(statements) RBRACE // lookahead token appears because option(statements) can begin with POUND
       . 

** Conflict (shift/reduce) in state 6.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            (?)

** In state 6, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 6, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 
