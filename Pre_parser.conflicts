
** Conflict (shift/reduce) in state 826.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACE list(inner_attr) list(statement)

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            block_expression 
                            LBRACE list(inner_attr) option(statements) RBRACE 
                                                    statements 
                                                    list(statement) exprs_without_block 
                                                                    operator_expression 
                                                                    expression QUESTION 
                                                                    exprs_with_block 
                                                                    (?)

** In state 826, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 826, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (reduce/reduce) in state 820.
** Tokens involved: STAR OR MINUS LT LPAREN LBRACK DOTDOTEQ DOTDOT AND
** The following explanations concentrate on token STAR.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACE list(inner_attr) exprs_with_block

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            block_expression 
                            LBRACE list(inner_attr) option(statements) RBRACE 
                                                    statements 
                                                    (?)

** In state 820, looking ahead at STAR, reducing production
** expression -> exprs_with_block
** is permitted because of the following sub-derivation:

exprs_without_block 
operator_expression 
expression STAR expression // lookahead token appears
exprs_with_block . 

** In state 820, looking ahead at STAR, reducing production
** option(SEMI) ->
** is permitted because of the following sub-derivation:

list(statement) 
statement list(statement) // lookahead token appears because list(statement) can begin with STAR
expression_statement // lookahead token is inherited
exprs_with_block option(SEMI) // lookahead token is inherited
                 . 

** Conflict (shift/reduce) in state 807.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACE list(inner_attr) list(outer_attr) LET pattern_no_top_alt COLON typ EQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            block_expression 
                            LBRACE list(inner_attr) option(statements) RBRACE 
                                                    statements 
                                                    list(statement) 
                                                    statement list(statement) 
                                                    let_statement 
                                                    list(outer_attr) LET pattern_no_top_alt COLON typ option(let_expr) SEMI 
                                                                                                      let_expr 
                                                                                                      EQ expression option(else_expr) 
                                                                                                         exprs_with_block 
                                                                                                         (?)

** In state 807, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 807, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 805.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACE list(inner_attr) list(outer_attr) LET pattern_no_top_alt COLON

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            block_expression 
                            LBRACE list(inner_attr) option(statements) RBRACE 
                                                    statements 
                                                    list(statement) 
                                                    statement list(statement) 
                                                    let_statement 
                                                    list(outer_attr) LET pattern_no_top_alt COLON typ option(let_expr) SEMI 
                                                                                                  type_no_bounds 
                                                                                                  (?)

** In state 805, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) 
. PATHSEP 

** In state 805, looking ahead at PATHSEP, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

trait_bound 
option(question_or_for) type_path // lookahead token appears because type_path can begin with PATHSEP
. 

** Conflict (shift/reduce) in state 803.
** Tokens involved: RAW_IDENT INT_LIT IDENT FLOAT_LIT
** The following explanations concentrate on token RAW_IDENT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACE list(inner_attr) list(outer_attr) LET

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            block_expression 
                            LBRACE list(inner_attr) option(statements) RBRACE 
                                                    statements 
                                                    list(statement) 
                                                    statement list(statement) 
                                                    let_statement 
                                                    list(outer_attr) LET pattern_no_top_alt COLON typ option(let_expr) SEMI 
                                                                         no_range_pattern 
                                                                         (?)

** In state 803, looking ahead at RAW_IDENT, shifting is permitted
** because of the following sub-derivation:

identifier_pattern 
ident option(pat_at) 
. RAW_IDENT 

** In state 803, looking ahead at RAW_IDENT, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

struct_pattern 
path_in_expression LBRACK option(struct_pattern_elements) RBRACK 
option(PATHSEP) separated_nonempty_list(PATHSEP,path_expr_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,path_expr_segment) can begin with RAW_IDENT
. 

** Conflict (shift/reduce) in state 780.
** Token involved: POUND
** This state is reached from program after reading:

list(outer_attr) MOD ident LBRACE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
                 unsafe_module 
                 safe_module 
                 (?)

** In state 780, looking ahead at POUND, shifting is permitted
** because of the following sub-derivation:

MOD ident LBRACE list(inner_attr) items RBRACE 
                 inner_attr list(inner_attr) 
                 . POUND NOT LBRACK attr RBRACK 

** In state 780, looking ahead at POUND, reducing production
** list(inner_attr) ->
** is permitted because of the following sub-derivation:

MOD ident LBRACE list(inner_attr) items RBRACE // lookahead token appears because items can begin with POUND
                 . 

** Conflict (shift/reduce) in state 774.
** Token involved: POUND
** This state is reached from program after reading:

list(outer_attr) UNSAFE MOD ident LBRACE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
                 unsafe_module 
                 (?)

** In state 774, looking ahead at POUND, shifting is permitted
** because of the following sub-derivation:

UNSAFE MOD ident LBRACE list(inner_attr) items RBRACE 
                        inner_attr list(inner_attr) 
                        . POUND NOT LBRACK attr RBRACK 

** In state 774, looking ahead at POUND, reducing production
** list(inner_attr) ->
** is permitted because of the following sub-derivation:

UNSAFE MOD ident LBRACE list(inner_attr) items RBRACE // lookahead token appears because items can begin with POUND
                        . 

** Conflict (shift/reduce) in state 758.
** Tokens involved: SUPER SELFVALUE RAW_IDENT IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token SUPER.
** This state is reached from program after reading:

list(outer_attr) USE simple_path_special LBRACE use_tree COMMA

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
                 use_declaration 
                 USE use_tree SEMI 
                     simple_path_special LBRACE use_trees RBRACE 
                                                nonempty_separated_or_terminated_list(COMMA,use_tree) 
                                                nonempty_list(terminated(use_tree,COMMA)) 
                                                use_tree COMMA nonempty_list(terminated(use_tree,COMMA)) 
                                                               use_tree COMMA 
                                                               (?)

** In state 758, looking ahead at SUPER, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

simple_path as_id_or_underscore 
option(PATHSEP) separated_nonempty_list(PATHSEP,simple_path_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,simple_path_segment) can begin with SUPER
. 

** In state 758, looking ahead at SUPER, shifting is permitted
** because of the following sub-derivation:

simple_path_special STAR 
nonempty_list(terminated(simple_path_segment,PATHSEP)) 
simple_path_segment PATHSEP 
. SUPER 

** Conflict (shift/reduce) in state 754.
** Tokens involved: SUPER SELFVALUE RAW_IDENT IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token SUPER.
** This state is reached from program after reading:

list(outer_attr) USE simple_path_special LBRACE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
                 use_declaration 
                 USE use_tree SEMI 
                     simple_path_special LBRACE use_trees RBRACE 
                                                nonempty_separated_or_terminated_list(COMMA,use_tree) 
                                                nonempty_list(terminated(use_tree,COMMA)) 
                                                use_tree COMMA 
                                                (?)

** In state 754, looking ahead at SUPER, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

simple_path as_id_or_underscore 
option(PATHSEP) separated_nonempty_list(PATHSEP,simple_path_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,simple_path_segment) can begin with SUPER
. 

** In state 754, looking ahead at SUPER, shifting is permitted
** because of the following sub-derivation:

simple_path_special STAR 
nonempty_list(terminated(simple_path_segment,PATHSEP)) 
simple_path_segment PATHSEP 
. SUPER 

** Conflict (shift/reduce) in state 745.
** Tokens involved: SUPER SELFVALUE RAW_IDENT IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token SUPER.
** This state is reached from program after reading:

list(outer_attr) USE PATHSEP

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
                 use_declaration 
                 USE use_tree SEMI 
                     (?)

** In state 745, looking ahead at SUPER, reducing production
** option(PATHSEP) -> PATHSEP
** is permitted because of the following sub-derivation:

simple_path as_id_or_underscore 
option(PATHSEP) separated_nonempty_list(PATHSEP,simple_path_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,simple_path_segment) can begin with SUPER
PATHSEP . 

** In state 745, looking ahead at SUPER, shifting is permitted
** because of the following sub-derivation:

simple_path_special STAR 
PATHSEP nonempty_list(terminated(simple_path_segment,PATHSEP)) 
        simple_path_segment PATHSEP 
        . SUPER 

** Conflict (shift/reduce) in state 744.
** Tokens involved: SUPER SELFVALUE RAW_IDENT IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token SUPER.
** This state is reached from program after reading:

list(outer_attr) USE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
                 use_declaration 
                 USE use_tree SEMI 
                     (?)

** In state 744, looking ahead at SUPER, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

simple_path as_id_or_underscore 
option(PATHSEP) separated_nonempty_list(PATHSEP,simple_path_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,simple_path_segment) can begin with SUPER
. 

** In state 744, looking ahead at SUPER, shifting is permitted
** because of the following sub-derivation:

simple_path_special STAR 
nonempty_list(terminated(simple_path_segment,PATHSEP)) 
simple_path_segment PATHSEP 
. SUPER 

** Conflict (shift/reduce) in state 741.
** Tokens involved: UNSAFE POUND
** The following explanations concentrate on token POUND.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACE list(inner_attr) outer_attr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            block_expression 
                            LBRACE list(inner_attr) option(statements) RBRACE 
                                                    statements 
                                                    (?)

** In state 741, looking ahead at POUND, reducing production
** nonempty_list(outer_attr) -> outer_attr
** is permitted because of the following sub-derivation:

exprs_without_block 
operator_expression 
expression QUESTION 
nonempty_list(outer_attr) exprs_without_block // lookahead token appears because exprs_without_block can begin with POUND
outer_attr . 

** In state 741, looking ahead at POUND, shifting is permitted
** because of the following sub-derivation:

list(statement) 
statement list(statement) 
item 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
           outer_attr list(outer_attr) 
           . POUND LBRACK attr RBRACK 

** Conflict (shift/reduce/reduce) in state 740.
** Tokens involved: WHILE UNSAFE UNDERSCORE TRUE SUPER STRING_LIT STAR SELFVALUE SELFTYPE RETURN RAW_STRING_LIT RAW_MUT RAW_IDENT RAW_C_STRING RAW_CONST RAW_BYTE_STRING POUND PATHSEP OR NOT MOVE MINUS MATCH LT LPAREN LOOP LIFETIME_OR_LABEL LBRACK LBRACE INT_LIT IF IDENT FOR FLOAT_LIT FALSE DOTDOTEQ DOTDOT DOLLAR_CRATE C_STRING CRATE CONTINUE CONST CHAR_LIT BYTE_STRING BYTE BREAK ASYNC AND AMPMUT
** The following explanations concentrate on token LBRACE.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACE list(inner_attr) statement

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            block_expression 
                            LBRACE list(inner_attr) option(statements) RBRACE 
                                                    statements 
                                                    (?)

** In state 740, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

list(statement) 
statement list(statement) 
          statement list(statement) 
          expression_statement 
          exprs_with_block option(SEMI) 
          block_expression 
          . LBRACE list(inner_attr) option(statements) RBRACE 

** In state 740, looking ahead at LBRACE, reducing production
** list(statement) ->
** is permitted because of the following sub-derivation:

list(statement) exprs_without_block // lookahead token appears because exprs_without_block can begin with LBRACE
statement list(statement) // lookahead token is inherited
          . 

** In state 740, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

list(statement) 
statement list(statement) 
          statement list(statement) 
          expression_statement 
          exprs_with_block option(SEMI) 
          loop_expression 
          option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
          . 

** Conflict (shift/reduce) in state 738.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ STAR expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 738, looking ahead at XOREQ, reducing production
** operator_expression -> STAR expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
STAR expression . 

** In state 738, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

STAR expression 
     exprs_without_block 
     operator_expression 
     expression . XOREQ expression 

** Conflict (shift/reduce) in state 736.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ RAW_MUT expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 736, looking ahead at XOREQ, reducing production
** operator_expression -> RAW_MUT expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
RAW_MUT expression . 

** In state 736, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

RAW_MUT expression 
        exprs_without_block 
        operator_expression 
        expression . XOREQ expression 

** Conflict (shift/reduce) in state 735.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ RAW_CONST expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 735, looking ahead at XOREQ, reducing production
** operator_expression -> RAW_CONST expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
RAW_CONST expression . 

** In state 735, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

RAW_CONST expression 
          exprs_without_block 
          operator_expression 
          expression . XOREQ expression 

** Conflict (shift/reduce) in state 730.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT STAR CONST

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               raw_pointer_type 
                               STAR CONST type_no_bounds 
                                          (?)

** In state 730, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) 
. PATHSEP 

** In state 730, looking ahead at PATHSEP, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

trait_bound 
option(question_or_for) type_path // lookahead token appears because type_path can begin with PATHSEP
. 

** Conflict (shift/reduce) in state 720.
** Token involved: RPAREN
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT LPAREN option(question_or_for) type_path

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               (?)

** In state 720, looking ahead at RPAREN, reducing production
** trait_bound -> option(question_or_for) type_path
** is permitted because of the following sub-derivation:

LPAREN typ RPAREN // lookahead token appears
       type_no_bounds // lookahead token is inherited
       trait_bound // lookahead token is inherited
       option(question_or_for) type_path . 

** In state 720, looking ahead at RPAREN, shifting is permitted
** because of the following sub-derivation:

trait_bound 
LPAREN option(question_or_for) type_path . RPAREN 

** Conflict (shift/reduce) in state 713.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT LPAREN typ COMMA

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               tuple_type 
                               LPAREN separated_or_terminated_list(COMMA,typ) RPAREN 
                                      list(terminated(typ,COMMA)) 
                                      typ COMMA list(terminated(typ,COMMA)) 
                                                typ COMMA list(terminated(typ,COMMA)) 
                                                type_no_bounds 
                                                (?)

** In state 713, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) 
. PATHSEP 

** In state 713, looking ahead at PATHSEP, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

trait_bound 
option(question_or_for) type_path // lookahead token appears because type_path can begin with PATHSEP
. 

** Conflict (shift/reduce) in state 711.
** Token involved: RPAREN
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT LPAREN typ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               (?)

** In state 711, looking ahead at RPAREN, reducing production
** separated_nonempty_list(COMMA,typ) -> typ
** is permitted because of the following sub-derivation:

tuple_type 
LPAREN separated_or_terminated_list(COMMA,typ) RPAREN // lookahead token appears
       loption(separated_nonempty_list(COMMA,typ)) // lookahead token is inherited
       separated_nonempty_list(COMMA,typ) // lookahead token is inherited
       typ . 

** In state 711, looking ahead at RPAREN, shifting is permitted
** because of the following sub-derivation:

LPAREN typ . RPAREN 

** Conflict (shift/reduce) in state 707.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ NOT expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 707, looking ahead at XOREQ, reducing production
** operator_expression -> NOT expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
NOT expression . 

** In state 707, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

NOT expression 
    exprs_without_block 
    operator_expression 
    expression . XOREQ expression 

** Conflict (shift/reduce) in state 705.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ MINUS expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 705, looking ahead at XOREQ, reducing production
** operator_expression -> MINUS expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
MINUS expression . 

** In state 705, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

MINUS expression 
      exprs_without_block 
      operator_expression 
      expression . XOREQ expression 

** Conflict (shift/reduce) in state 703.
** Token involved: POUND
** This state is reached from program after reading:

list(outer_attr) MOD ident LBRACE inner_attr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
                 unsafe_module 
                 safe_module 
                 (?)

** In state 703, looking ahead at POUND, shifting is permitted
** because of the following sub-derivation:

MOD ident LBRACE list(inner_attr) items RBRACE 
                 inner_attr list(inner_attr) 
                            inner_attr list(inner_attr) 
                            . POUND NOT LBRACK attr RBRACK 

** In state 703, looking ahead at POUND, reducing production
** list(inner_attr) ->
** is permitted because of the following sub-derivation:

MOD ident LBRACE list(inner_attr) items RBRACE // lookahead token appears because items can begin with POUND
                 inner_attr list(inner_attr) // lookahead token is inherited
                            . 

** Conflict (shift/reduce) in state 701.
** Tokens involved: POUND OR
** The following explanations concentrate on token POUND.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ MATCH scrutinee LBRACE list(inner_attr) first_arms

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            match_expression 
                            MATCH scrutinee LBRACE list(inner_attr) option(match_arms) RBRACE 
                                                                    match_arms 
                                                                    (?)

** In state 701, looking ahead at POUND, reducing production
** list(first_arms) ->
** is permitted because of the following sub-derivation:

list(first_arms) match_arm FATARROW expression option(COMMA) // lookahead token appears because match_arm can begin with POUND
first_arms list(first_arms) // lookahead token is inherited
           . 

** In state 701, looking ahead at POUND, shifting is permitted
** because of the following sub-derivation:

list(first_arms) match_arm FATARROW expression option(COMMA) 
first_arms list(first_arms) 
           first_arms list(first_arms) 
           match_arm FATARROW block_or_not 
           list(outer_attr) pattern option(match_arm_guard) 
           outer_attr list(outer_attr) 
           . POUND LBRACK attr RBRACK 

** Conflict (shift/reduce) in state 698.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ MATCH scrutinee LBRACE list(inner_attr) list(first_arms) match_arm FATARROW

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            match_expression 
                            MATCH scrutinee LBRACE list(inner_attr) option(match_arms) RBRACE 
                                                                    match_arms 
                                                                    list(first_arms) match_arm FATARROW expression option(COMMA) 
                                                                                                        exprs_with_block 
                                                                                                        (?)

** In state 698, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 698, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 692.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ MATCH scrutinee LBRACE list(inner_attr) list(outer_attr) pattern IF

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            match_expression 
                            MATCH scrutinee LBRACE list(inner_attr) option(match_arms) RBRACE 
                                                                    match_arms 
                                                                    list(first_arms) match_arm FATARROW expression option(COMMA) 
                                                                    first_arms list(first_arms) 
                                                                    match_arm FATARROW block_or_not 
                                                                    list(outer_attr) pattern option(match_arm_guard) 
                                                                                             match_arm_guard 
                                                                                             IF expression 
                                                                                                exprs_with_block 
                                                                                                (?)

** In state 692, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 692, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (reduce/reduce) in state 686.
** Token involved: OR
** This state is reached from program after reading:

POUND LBRACK simple_path EQ MATCH scrutinee LBRACE list(inner_attr) match_arm FATARROW exprs_with_block

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            match_expression 
                            MATCH scrutinee LBRACE list(inner_attr) option(match_arms) RBRACE 
                                                                    match_arms 
                                                                    list(first_arms) match_arm FATARROW expression option(COMMA) 
                                                                    (?)

** In state 686, looking ahead at OR, reducing production
** expression -> exprs_with_block
** is permitted because of the following sub-derivation:

first_arms list(first_arms) 
match_arm FATARROW block_or_not 
                   exprs_without_block COMMA 
                   operator_expression 
                   expression OR expression // lookahead token appears
                   exprs_with_block . 

** In state 686, looking ahead at OR, reducing production
** option(COMMA) ->
** is permitted because of the following sub-derivation:

first_arms list(first_arms) // lookahead token appears because list(first_arms) can begin with OR
match_arm FATARROW block_or_not // lookahead token is inherited
                   exprs_with_block option(COMMA) // lookahead token is inherited
                                    . 

** Conflict (shift/reduce) in state 683.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ MATCH scrutinee LBRACE list(inner_attr) match_arm FATARROW

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            match_expression 
                            MATCH scrutinee LBRACE list(inner_attr) option(match_arms) RBRACE 
                                                                    match_arms 
                                                                    list(first_arms) match_arm FATARROW expression option(COMMA) 
                                                                    first_arms list(first_arms) 
                                                                    match_arm FATARROW block_or_not 
                                                                                       exprs_with_block option(COMMA) 
                                                                                       (?)

** In state 683, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 683, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 678.
** Tokens involved: POUND OR
** The following explanations concentrate on token POUND.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ MATCH scrutinee LBRACE list(inner_attr)

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            match_expression 
                            MATCH scrutinee LBRACE list(inner_attr) option(match_arms) RBRACE 
                                                                    match_arms 
                                                                    (?)

** In state 678, looking ahead at POUND, reducing production
** list(first_arms) ->
** is permitted because of the following sub-derivation:

list(first_arms) match_arm FATARROW expression option(COMMA) // lookahead token appears because match_arm can begin with POUND
. 

** In state 678, looking ahead at POUND, shifting is permitted
** because of the following sub-derivation:

list(first_arms) match_arm FATARROW expression option(COMMA) 
first_arms list(first_arms) 
match_arm FATARROW block_or_not 
list(outer_attr) pattern option(match_arm_guard) 
outer_attr list(outer_attr) 
. POUND LBRACK attr RBRACK 

** Conflict (shift/reduce) in state 677.
** Token involved: POUND
** This state is reached from program after reading:

POUND LBRACK simple_path EQ MATCH scrutinee LBRACE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            match_expression 
                            (?)

** In state 677, looking ahead at POUND, shifting is permitted
** because of the following sub-derivation:

MATCH scrutinee LBRACE list(inner_attr) option(match_arms) RBRACE 
                       inner_attr list(inner_attr) 
                       . POUND NOT LBRACK attr RBRACK 

** In state 677, looking ahead at POUND, reducing production
** list(inner_attr) ->
** is permitted because of the following sub-derivation:

MATCH scrutinee LBRACE list(inner_attr) option(match_arms) RBRACE // lookahead token appears because option(match_arms) can begin with POUND
                       . 

** Conflict (shift/reduce) in state 674.
** Token involved: RPAREN
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LPAREN expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            (?)

** In state 674, looking ahead at RPAREN, shifting is permitted
** because of the following sub-derivation:

grouped_expression 
LPAREN expression . RPAREN 

** In state 674, looking ahead at RPAREN, reducing production
** separated_nonempty_list(COMMA,expression) -> expression
** is permitted because of the following sub-derivation:

tuple_expression 
LPAREN option(tuple_elements) RPAREN // lookahead token appears
       tuple_elements // lookahead token is inherited
       separated_nonempty_list(COMMA,expression) // lookahead token is inherited
       expression . 

** Conflict (shift/reduce) in state 665.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACK expression COMMA

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            array_expression 
                            LBRACK array_elements RBRACK 
                                   nonempty_separated_or_terminated_list(COMMA,expression) 
                                   nonempty_list(terminated(expression,COMMA)) 
                                   expression COMMA nonempty_list(terminated(expression,COMMA)) 
                                                    expression COMMA 
                                                    exprs_with_block 
                                                    (?)

** In state 665, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 665, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 663.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACK expression SEMI

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            array_expression 
                            LBRACK array_elements RBRACK 
                                   expression SEMI expression 
                                                   exprs_with_block 
                                                   (?)

** In state 663, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 663, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 657.
** Token involved: ELSE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACE list(inner_attr) list(outer_attr) LET pattern_no_top_alt COLON typ EQ IF expression block_expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            block_expression 
                            LBRACE list(inner_attr) option(statements) RBRACE 
                                                    statements 
                                                    list(statement) 
                                                    statement list(statement) 
                                                    let_statement 
                                                    list(outer_attr) LET pattern_no_top_alt COLON typ option(let_expr) SEMI 
                                                                                                      let_expr 
                                                                                                      (?)

** In state 657, looking ahead at ELSE, shifting is permitted
** because of the following sub-derivation:

EQ expression option(else_expr) 
   exprs_with_block 
   if_expression 
   IF expression block_expression else_opt 
                                  . ELSE block_expression 

** In state 657, looking ahead at ELSE, reducing production
** else_opt ->
** is permitted because of the following sub-derivation:

EQ expression option(else_expr) // lookahead token appears because option(else_expr) can begin with ELSE
   exprs_with_block // lookahead token is inherited
   if_expression // lookahead token is inherited
   IF expression block_expression else_opt // lookahead token is inherited
                                  . 

** Conflict (shift/reduce) in state 650.
** Token involved: ELSE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACE list(inner_attr) list(outer_attr) LET pattern_no_top_alt COLON typ EQ IF LET pattern EQ expression block_expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            block_expression 
                            LBRACE list(inner_attr) option(statements) RBRACE 
                                                    statements 
                                                    list(statement) 
                                                    statement list(statement) 
                                                    let_statement 
                                                    list(outer_attr) LET pattern_no_top_alt COLON typ option(let_expr) SEMI 
                                                                                                      let_expr 
                                                                                                      (?)

** In state 650, looking ahead at ELSE, shifting is permitted
** because of the following sub-derivation:

EQ expression option(else_expr) 
   exprs_with_block 
   if_let_expression 
   IF LET pattern EQ expression block_expression else_opt 
                                                 . ELSE block_expression 

** In state 650, looking ahead at ELSE, reducing production
** else_opt ->
** is permitted because of the following sub-derivation:

EQ expression option(else_expr) // lookahead token appears because option(else_expr) can begin with ELSE
   exprs_with_block // lookahead token is inherited
   if_let_expression // lookahead token is inherited
   IF LET pattern EQ expression block_expression else_opt // lookahead token is inherited
                                                 . 

** Conflict (shift/reduce) in state 648.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ DOTDOTEQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            (?)

** In state 648, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

range_expression 
DOTDOTEQ expression 
         exprs_without_block 
         operator_expression 
         expression . XOREQ expression 

** In state 648, looking ahead at XOREQ, reducing production
** range_expression -> DOTDOTEQ expression
** is permitted because of the following sub-derivation:

operator_expression 
expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
range_expression // lookahead token is inherited
DOTDOTEQ expression . 

** Conflict (shift/reduce) in state 647.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ DOTDOT expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            (?)

** In state 647, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

range_expression 
DOTDOT expression 
       exprs_without_block 
       operator_expression 
       expression . XOREQ expression 

** In state 647, looking ahead at XOREQ, reducing production
** range_expression -> DOTDOT expression
** is permitted because of the following sub-derivation:

operator_expression 
expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
range_expression // lookahead token is inherited
DOTDOT expression . 

** Conflict (shift/reduce) in state 646.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ RETURN expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            (?)

** In state 646, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

return_expression 
RETURN option(expression) 
       expression 
       exprs_without_block 
       operator_expression 
       expression . XOREQ expression 

** In state 646, looking ahead at XOREQ, reducing production
** option(expression) -> expression
** is permitted because of the following sub-derivation:

operator_expression 
expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
return_expression // lookahead token is inherited
RETURN option(expression) // lookahead token is inherited
       expression . 

** Conflict (shift/reduce) in state 641.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ ASYNC MOVE OR option(closure_params) OR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            ASYNC MOVE OR option(closure_params) OR expr_or_typ_block 
                                                                    expression 
                                                                    exprs_with_block 
                                                                    (?)

** In state 641, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 641, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 629.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR list(outer_attr) pattern_no_top_alt COLON

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                               closure_params 
                               nonempty_separated_or_terminated_list(COMMA,closure_param) 
                               nonempty_list(terminated(closure_param,COMMA)) 
                               closure_param COMMA 
                               list(outer_attr) pattern_no_top_alt option(typ_opt) 
                                                                   typ_opt 
                                                                   COLON typ 
                                                                         type_no_bounds 
                                                                         (?)

** In state 629, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) 
. PATHSEP 

** In state 629, looking ahead at PATHSEP, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

trait_bound 
option(question_or_for) type_path // lookahead token appears because type_path can begin with PATHSEP
. 

** Conflict (shift/reduce) in state 627.
** Tokens involved: RAW_IDENT INT_LIT IDENT FLOAT_LIT
** The following explanations concentrate on token RAW_IDENT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR list(outer_attr)

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                               closure_params 
                               nonempty_separated_or_terminated_list(COMMA,closure_param) 
                               nonempty_list(terminated(closure_param,COMMA)) 
                               closure_param COMMA 
                               list(outer_attr) pattern_no_top_alt option(typ_opt) 
                                                no_range_pattern 
                                                (?)

** In state 627, looking ahead at RAW_IDENT, shifting is permitted
** because of the following sub-derivation:

identifier_pattern 
ident option(pat_at) 
. RAW_IDENT 

** In state 627, looking ahead at RAW_IDENT, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

struct_pattern 
path_in_expression LBRACK option(struct_pattern_elements) RBRACK 
option(PATHSEP) separated_nonempty_list(PATHSEP,path_expr_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,path_expr_segment) can begin with RAW_IDENT
. 

** Conflict (shift/reduce) in state 623.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR option(closure_params) OR expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            (?)

** In state 623, looking ahead at XOREQ, reducing production
** expr_or_typ_block -> expression
** is permitted because of the following sub-derivation:

operator_expression 
expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
closure_expression // lookahead token is inherited
OR option(closure_params) OR expr_or_typ_block // lookahead token is inherited
                             expression . 

** In state 623, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

closure_expression 
OR option(closure_params) OR expr_or_typ_block 
                             expression 
                             exprs_without_block 
                             operator_expression 
                             expression . XOREQ expression 

** Conflict (shift/reduce) in state 622.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ AND expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 622, looking ahead at XOREQ, reducing production
** operator_expression -> AND expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
AND expression . 

** In state 622, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

AND expression 
    exprs_without_block 
    operator_expression 
    expression . XOREQ expression 

** Conflict (shift/reduce) in state 621.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ AMPMUT expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 621, looking ahead at XOREQ, reducing production
** operator_expression -> AMPMUT expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
AMPMUT expression . 

** In state 621, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

AMPMUT expression 
       exprs_without_block 
       operator_expression 
       expression . XOREQ expression 

** Conflict (shift/reduce) in state 617.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ path_in_expression LBRACE loption(separated_nonempty_list(COMMA,struct_expr_field)) COMMA DOTDOT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            struct_expression 
                            path_in_expression LBRACE struct_expr_field_or_struct_base_opt RBRACE 
                                                      struct_expr_fields 
                                                      loption(separated_nonempty_list(COMMA,struct_expr_field)) COMMA struct_base 
                                                                                                                      DOTDOT expression 
                                                                                                                             exprs_with_block 
                                                                                                                             (?)

** In state 617, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 617, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 611.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ path_in_expression LBRACE list(outer_attr) ident COLON

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            struct_expression 
                            path_in_expression LBRACE struct_expr_field_or_struct_base_opt RBRACE 
                                                      struct_expr_fields 
                                                      loption(separated_nonempty_list(COMMA,struct_expr_field)) COMMA struct_base 
                                                      separated_nonempty_list(COMMA,struct_expr_field) 
                                                      struct_expr_field 
                                                      list(outer_attr) ident COLON expression 
                                                                                   exprs_with_block 
                                                                                   (?)

** In state 611, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 611, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 605.
** Token involved: COMMA
** This state is reached from program after reading:

POUND LBRACK simple_path EQ path_in_expression LBRACE struct_expr_field

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            struct_expression 
                            path_in_expression LBRACE struct_expr_field_or_struct_base_opt RBRACE 
                                                      struct_expr_fields 
                                                      (?)

** In state 605, looking ahead at COMMA, shifting is permitted
** because of the following sub-derivation:

separated_or_terminated_list(COMMA,struct_expr_field) 
list(terminated(struct_expr_field,COMMA)) 
struct_expr_field . COMMA list(terminated(struct_expr_field,COMMA)) 

** In state 605, looking ahead at COMMA, reducing production
** separated_nonempty_list(COMMA,struct_expr_field) -> struct_expr_field
** is permitted because of the following sub-derivation:

loption(separated_nonempty_list(COMMA,struct_expr_field)) COMMA struct_base // lookahead token appears
separated_nonempty_list(COMMA,struct_expr_field) // lookahead token is inherited
struct_expr_field . 

** Conflict (shift/reduce) in state 600.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ path_in_expression LBRACE DOTDOT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            struct_expression 
                            path_in_expression LBRACE struct_expr_field_or_struct_base_opt RBRACE 
                                                      DOTDOT expression 
                                                             exprs_with_block 
                                                             (?)

** In state 600, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 600, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (reduce/reduce) in state 599.
** Token involved: RBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ path_in_expression LBRACE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            struct_expression 
                            path_in_expression LBRACE struct_expr_field_or_struct_base_opt RBRACE // lookahead token appears
                                                      (?)

** In state 599, looking ahead at RBRACE, reducing production
** list(terminated(struct_expr_field,COMMA)) ->
** is permitted because of the following sub-derivation:

struct_expr_fields // lookahead token is inherited
separated_or_terminated_list(COMMA,struct_expr_field) // lookahead token is inherited
list(terminated(struct_expr_field,COMMA)) // lookahead token is inherited
. 

** In state 599, looking ahead at RBRACE, reducing production
** loption(separated_nonempty_list(COMMA,struct_expr_field)) ->
** is permitted because of the following sub-derivation:

struct_expr_fields // lookahead token is inherited
separated_or_terminated_list(COMMA,struct_expr_field) // lookahead token is inherited
loption(separated_nonempty_list(COMMA,struct_expr_field)) // lookahead token is inherited
. 

** In state 599, looking ahead at RBRACE, reducing production
** struct_expr_field_or_struct_base_opt ->
** is permitted because of the following sub-derivation:

. 

** Conflict (shift/reduce) in state 586.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ option(loop_label) FOR pattern IN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            loop_expression 
                            option(loop_label) loop_switch 
                                               iterator_loop_expression 
                                               FOR pattern IN expression block_expression 
                                                              exprs_with_block 
                                                              (?)

** In state 586, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 586, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 575.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LPAREN expression COMMA

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            tuple_expression 
                            LPAREN option(tuple_elements) RPAREN 
                                   tuple_elements 
                                   separated_nonempty_list(COMMA,expression) 
                                   expression COMMA separated_nonempty_list(COMMA,expression) 
                                                    expression 
                                                    exprs_with_block 
                                                    (?)

** In state 575, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 575, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 574.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression AND expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 574, looking ahead at XOREQ, reducing production
** operator_expression -> expression AND expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression AND expression . 

** In state 574, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression AND expression 
               exprs_without_block 
               operator_expression 
               expression . XOREQ expression 

** Conflict (shift/reduce) in state 573.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression AND

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression AND expression 
                                           exprs_with_block 
                                           (?)

** In state 573, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 573, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 572.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression ANDAND expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 572, looking ahead at XOREQ, reducing production
** operator_expression -> expression ANDAND expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression ANDAND expression . 

** In state 572, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression ANDAND expression 
                  exprs_without_block 
                  operator_expression 
                  expression . XOREQ expression 

** Conflict (shift/reduce) in state 571.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression ANDAND

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression ANDAND expression 
                                              exprs_with_block 
                                              (?)

** In state 571, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 571, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 570.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression ANDEQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 570, looking ahead at XOREQ, reducing production
** operator_expression -> expression ANDEQ expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression ANDEQ expression . 

** In state 570, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression ANDEQ expression 
                 exprs_without_block 
                 operator_expression 
                 expression . XOREQ expression 

** Conflict (shift/reduce) in state 569.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression ANDEQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression ANDEQ expression 
                                             exprs_with_block 
                                             (?)

** In state 569, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 569, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 567.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression AS

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression AS type_no_bounds 
                                          (?)

** In state 567, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) 
. PATHSEP 

** In state 567, looking ahead at PATHSEP, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

trait_bound 
option(question_or_for) type_path // lookahead token appears because type_path can begin with PATHSEP
. 

** Conflict (reduce/reduce) in state 566.
** Token involved: LPAREN
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression DOT ident

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            (?)

** In state 566, looking ahead at LPAREN, reducing production
** field_expression -> expression DOT ident
** is permitted because of the following sub-derivation:

call_expression 
expression LPAREN call_params RPAREN // lookahead token appears
exprs_without_block // lookahead token is inherited
field_expression // lookahead token is inherited
expression DOT ident . 

** In state 566, looking ahead at LPAREN, reducing production
** path_ident_segment -> ident
** is permitted because of the following sub-derivation:

method_call_expression 
expression DOT path_expr_segment LPAREN call_params RPAREN // lookahead token appears
               path_ident_segment option(path_genarg) // lookahead token is inherited because option(path_genarg) can vanish
               ident . 

** Conflict (shift/reduce) in state 554.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression DOT path_expr_segment LPAREN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            method_call_expression 
                            expression DOT path_expr_segment LPAREN call_params RPAREN 
                                                                    loption(separated_nonempty_list(COMMA,expression)) 
                                                                    separated_nonempty_list(COMMA,expression) 
                                                                    expression 
                                                                    exprs_with_block 
                                                                    (?)

** In state 554, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 554, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 549.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression DOTDOT expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            (?)

** In state 549, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

range_expression 
expression DOTDOT expression 
                  exprs_without_block 
                  operator_expression 
                  expression . XOREQ expression 

** In state 549, looking ahead at XOREQ, reducing production
** range_expression -> expression DOTDOT expression
** is permitted because of the following sub-derivation:

operator_expression 
expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
range_expression // lookahead token is inherited
expression DOTDOT expression . 

** Conflict (shift/reduce) in state 548.
** Tokens involved: STAR OR MINUS LT LPAREN LBRACK LBRACE DOTDOTEQ DOTDOT AND
** The following explanations concentrate on token STAR.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression DOTDOT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            (?)

** In state 548, looking ahead at STAR, shifting is permitted
** because of the following sub-derivation:

range_expression 
expression DOTDOT expression 
                  exprs_without_block 
                  operator_expression 
                  . STAR expression 

** In state 548, looking ahead at STAR, reducing production
** range_expression -> expression DOTDOT
** is permitted because of the following sub-derivation:

operator_expression 
expression STAR expression // lookahead token appears
exprs_without_block // lookahead token is inherited
range_expression // lookahead token is inherited
expression DOTDOT . 

** Conflict (shift/reduce) in state 547.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression DOTDOTEQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            (?)

** In state 547, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

range_expression 
expression DOTDOTEQ expression 
                    exprs_without_block 
                    operator_expression 
                    expression . XOREQ expression 

** In state 547, looking ahead at XOREQ, reducing production
** range_expression -> expression DOTDOTEQ expression
** is permitted because of the following sub-derivation:

operator_expression 
expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
range_expression // lookahead token is inherited
expression DOTDOTEQ expression . 

** Conflict (shift/reduce) in state 546.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression DOTDOTEQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            range_expression 
                            expression DOTDOTEQ expression 
                                                exprs_with_block 
                                                (?)

** In state 546, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 546, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 545.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression EQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 545, looking ahead at XOREQ, reducing production
** operator_expression -> expression EQ expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression EQ expression . 

** In state 545, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression EQ expression 
              exprs_without_block 
              operator_expression 
              expression . XOREQ expression 

** Conflict (shift/reduce) in state 544.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression EQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression EQ expression 
                                          exprs_with_block 
                                          (?)

** In state 544, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 544, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 543.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression EQEQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 543, looking ahead at XOREQ, reducing production
** operator_expression -> expression EQEQ expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression EQEQ expression . 

** In state 543, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression EQEQ expression 
                exprs_without_block 
                operator_expression 
                expression . XOREQ expression 

** Conflict (shift/reduce) in state 542.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression EQEQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression EQEQ expression 
                                            exprs_with_block 
                                            (?)

** In state 542, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 542, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 541.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression GE expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 541, looking ahead at XOREQ, reducing production
** operator_expression -> expression GE expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression GE expression . 

** In state 541, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression GE expression 
              exprs_without_block 
              operator_expression 
              expression . XOREQ expression 

** Conflict (shift/reduce) in state 540.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression GE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression GE expression 
                                          exprs_with_block 
                                          (?)

** In state 540, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 540, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 539.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression GT expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 539, looking ahead at XOREQ, reducing production
** operator_expression -> expression GT expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression GT expression . 

** In state 539, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression GT expression 
              exprs_without_block 
              operator_expression 
              expression . XOREQ expression 

** Conflict (shift/reduce) in state 538.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression GT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression GT expression 
                                          exprs_with_block 
                                          (?)

** In state 538, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 538, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 535.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression LBRACK

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            index_expression 
                            expression LBRACK expression RBRACK 
                                              exprs_with_block 
                                              (?)

** In state 535, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 535, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 534.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression LE expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 534, looking ahead at XOREQ, reducing production
** operator_expression -> expression LE expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression LE expression . 

** In state 534, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression LE expression 
              exprs_without_block 
              operator_expression 
              expression . XOREQ expression 

** Conflict (shift/reduce) in state 533.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression LE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression LE expression 
                                          exprs_with_block 
                                          (?)

** In state 533, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 533, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 529.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression LPAREN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            call_expression 
                            expression LPAREN call_params RPAREN 
                                              loption(separated_nonempty_list(COMMA,expression)) 
                                              separated_nonempty_list(COMMA,expression) 
                                              expression 
                                              exprs_with_block 
                                              (?)

** In state 529, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 529, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 528.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression LT expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 528, looking ahead at XOREQ, reducing production
** operator_expression -> expression LT expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression LT expression . 

** In state 528, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression LT expression 
              exprs_without_block 
              operator_expression 
              expression . XOREQ expression 

** Conflict (shift/reduce) in state 527.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression LT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression LT expression 
                                          exprs_with_block 
                                          (?)

** In state 527, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 527, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 526.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression MINUS expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 526, looking ahead at XOREQ, reducing production
** operator_expression -> expression MINUS expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression MINUS expression . 

** In state 526, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression MINUS expression 
                 exprs_without_block 
                 operator_expression 
                 expression . XOREQ expression 

** Conflict (shift/reduce) in state 525.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression MINUS

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression MINUS expression 
                                             exprs_with_block 
                                             (?)

** In state 525, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 525, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 524.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression MINUSEQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 524, looking ahead at XOREQ, reducing production
** operator_expression -> expression MINUSEQ expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression MINUSEQ expression . 

** In state 524, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression MINUSEQ expression 
                   exprs_without_block 
                   operator_expression 
                   expression . XOREQ expression 

** Conflict (shift/reduce) in state 523.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression MINUSEQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression MINUSEQ expression 
                                               exprs_with_block 
                                               (?)

** In state 523, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 523, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 522.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression NE expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 522, looking ahead at XOREQ, reducing production
** operator_expression -> expression NE expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression NE expression . 

** In state 522, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression NE expression 
              exprs_without_block 
              operator_expression 
              expression . XOREQ expression 

** Conflict (shift/reduce) in state 521.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression NE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression NE expression 
                                          exprs_with_block 
                                          (?)

** In state 521, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 521, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 520.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression OR expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 520, looking ahead at XOREQ, reducing production
** operator_expression -> expression OR expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression OR expression . 

** In state 520, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression OR expression 
              exprs_without_block 
              operator_expression 
              expression . XOREQ expression 

** Conflict (shift/reduce) in state 519.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression OR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression OR expression 
                                          exprs_with_block 
                                          (?)

** In state 519, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 519, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 518.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression OREQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 518, looking ahead at XOREQ, reducing production
** operator_expression -> expression OREQ expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression OREQ expression . 

** In state 518, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression OREQ expression 
                exprs_without_block 
                operator_expression 
                expression . XOREQ expression 

** Conflict (shift/reduce) in state 517.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression OREQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression OREQ expression 
                                            exprs_with_block 
                                            (?)

** In state 517, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 517, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 516.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression OROR expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 516, looking ahead at XOREQ, reducing production
** operator_expression -> expression OROR expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression OROR expression . 

** In state 516, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression OROR expression 
                exprs_without_block 
                operator_expression 
                expression . XOREQ expression 

** Conflict (shift/reduce) in state 515.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression OROR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression OROR expression 
                                            exprs_with_block 
                                            (?)

** In state 515, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 515, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 514.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression PERCENT expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 514, looking ahead at XOREQ, reducing production
** operator_expression -> expression PERCENT expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression PERCENT expression . 

** In state 514, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression PERCENT expression 
                   exprs_without_block 
                   operator_expression 
                   expression . XOREQ expression 

** Conflict (shift/reduce) in state 513.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression PERCENT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression PERCENT expression 
                                               exprs_with_block 
                                               (?)

** In state 513, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 513, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 512.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression PLUS expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 512, looking ahead at XOREQ, reducing production
** operator_expression -> expression PLUS expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression PLUS expression . 

** In state 512, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression PLUS expression 
                exprs_without_block 
                operator_expression 
                expression . XOREQ expression 

** Conflict (shift/reduce) in state 511.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression PLUS

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression PLUS expression 
                                            exprs_with_block 
                                            (?)

** In state 511, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 511, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 510.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression PLUSEQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 510, looking ahead at XOREQ, reducing production
** operator_expression -> expression PLUSEQ expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression PLUSEQ expression . 

** In state 510, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression PLUSEQ expression 
                  exprs_without_block 
                  operator_expression 
                  expression . XOREQ expression 

** Conflict (shift/reduce) in state 509.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression PLUSEQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression PLUSEQ expression 
                                              exprs_with_block 
                                              (?)

** In state 509, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 509, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 507.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SHL expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 507, looking ahead at XOREQ, reducing production
** operator_expression -> expression SHL expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression SHL expression . 

** In state 507, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression SHL expression 
               exprs_without_block 
               operator_expression 
               expression . XOREQ expression 

** Conflict (shift/reduce) in state 506.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SHL

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression SHL expression 
                                           exprs_with_block 
                                           (?)

** In state 506, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 506, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 505.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SHLEQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 505, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression SHLEQ expression 
                 exprs_without_block 
                 operator_expression 
                 expression . XOREQ expression 

** In state 505, looking ahead at XOREQ, reducing production
** operator_expression -> expression SHLEQ expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression SHLEQ expression . 

** Conflict (shift/reduce) in state 504.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SHLEQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression SHLEQ expression 
                                             exprs_with_block 
                                             (?)

** In state 504, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 504, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 503.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SHR expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 503, looking ahead at XOREQ, reducing production
** operator_expression -> expression SHR expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression SHR expression . 

** In state 503, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression SHR expression 
               exprs_without_block 
               operator_expression 
               expression . XOREQ expression 

** Conflict (shift/reduce) in state 502.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SHR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression SHR expression 
                                           exprs_with_block 
                                           (?)

** In state 502, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 502, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 501.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SHREQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 501, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression SHREQ expression 
                 exprs_without_block 
                 operator_expression 
                 expression . XOREQ expression 

** In state 501, looking ahead at XOREQ, reducing production
** operator_expression -> expression SHREQ expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression SHREQ expression . 

** Conflict (shift/reduce) in state 500.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SHREQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression SHREQ expression 
                                             exprs_with_block 
                                             (?)

** In state 500, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 500, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 499.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SLASH expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 499, looking ahead at XOREQ, reducing production
** operator_expression -> expression SLASH expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression SLASH expression . 

** In state 499, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression SLASH expression 
                 exprs_without_block 
                 operator_expression 
                 expression . XOREQ expression 

** Conflict (shift/reduce) in state 498.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SLASH

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression SLASH expression 
                                             exprs_with_block 
                                             (?)

** In state 498, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 498, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 497.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SLASHEQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 497, looking ahead at XOREQ, reducing production
** operator_expression -> expression SLASHEQ expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression SLASHEQ expression . 

** In state 497, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression SLASHEQ expression 
                   exprs_without_block 
                   operator_expression 
                   expression . XOREQ expression 

** Conflict (shift/reduce) in state 496.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression SLASHEQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression SLASHEQ expression 
                                               exprs_with_block 
                                               (?)

** In state 496, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 496, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 495.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression STAR expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 495, looking ahead at XOREQ, reducing production
** operator_expression -> expression STAR expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression STAR expression . 

** In state 495, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression STAR expression 
                exprs_without_block 
                operator_expression 
                expression . XOREQ expression 

** Conflict (shift/reduce) in state 494.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression STAR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression STAR expression 
                                            exprs_with_block 
                                            (?)

** In state 494, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 494, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 493.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression STAREQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 493, looking ahead at XOREQ, reducing production
** operator_expression -> expression STAREQ expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression STAREQ expression . 

** In state 493, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression STAREQ expression 
                  exprs_without_block 
                  operator_expression 
                  expression . XOREQ expression 

** Conflict (shift/reduce) in state 492.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression STAREQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression STAREQ expression 
                                              exprs_with_block 
                                              (?)

** In state 492, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 492, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 491.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression XOR expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 491, looking ahead at XOREQ, reducing production
** operator_expression -> expression XOR expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression XOR expression . 

** In state 491, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression XOR expression 
               exprs_without_block 
               operator_expression 
               expression . XOREQ expression 

** Conflict (shift/reduce) in state 490.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression XOR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression XOR expression 
                                           exprs_with_block 
                                           (?)

** In state 490, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 490, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 489.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression XOREQ expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            (?)

** In state 489, looking ahead at XOREQ, shifting is permitted
** because of the following sub-derivation:

expression XOREQ expression 
                 exprs_without_block 
                 operator_expression 
                 expression . XOREQ expression 

** In state 489, looking ahead at XOREQ, reducing production
** operator_expression -> expression XOREQ expression
** is permitted because of the following sub-derivation:

expression XOREQ expression // lookahead token appears
exprs_without_block // lookahead token is inherited
operator_expression // lookahead token is inherited
expression XOREQ expression . 

** Conflict (shift/reduce) in state 486.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ expression XOREQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            expression XOREQ expression 
                                             exprs_with_block 
                                             (?)

** In state 486, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 486, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (reduce/reduce) in state 484.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ nonempty_list(outer_attr) exprs_with_block

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            (?)

** In state 484, looking ahead at XOREQ, reducing production
** expression -> nonempty_list(outer_attr) exprs_with_block
** is permitted because of the following sub-derivation:

exprs_without_block 
operator_expression 
expression XOREQ expression // lookahead token appears
nonempty_list(outer_attr) exprs_with_block . 

** In state 484, looking ahead at XOREQ, reducing production
** expression -> exprs_with_block
** is permitted because of the following sub-derivation:

nonempty_list(outer_attr) exprs_without_block 
                          operator_expression 
                          expression XOREQ expression // lookahead token appears
                          exprs_with_block . 

** Conflict (reduce/reduce) in state 483.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK GT GE EQEQ EQ DOTDOTEQ DOTDOT DOT AS ANDEQ ANDAND AND
** The following explanations concentrate on token XOREQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ nonempty_list(outer_attr) exprs_without_block

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            (?)

** In state 483, looking ahead at XOREQ, reducing production
** expression -> nonempty_list(outer_attr) exprs_without_block
** is permitted because of the following sub-derivation:

exprs_without_block 
operator_expression 
expression XOREQ expression // lookahead token appears
nonempty_list(outer_attr) exprs_without_block . 

** In state 483, looking ahead at XOREQ, reducing production
** expression -> exprs_without_block
** is permitted because of the following sub-derivation:

nonempty_list(outer_attr) exprs_without_block 
                          operator_expression 
                          expression XOREQ expression // lookahead token appears
                          exprs_without_block . 

** Conflict (shift/reduce) in state 472.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ nonempty_list(outer_attr)

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            nonempty_list(outer_attr) exprs_with_block 
                                                      (?)

** In state 472, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 472, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 468.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ option(loop_label) WHILE LET pattern EQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            loop_expression 
                            option(loop_label) loop_switch 
                                               predicate_pattern_loop_expression 
                                               WHILE LET pattern EQ scrutinee block_expression 
                                                                    expression 
                                                                    exprs_with_block 
                                                                    (?)

** In state 468, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 468, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 465.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ option(loop_label) WHILE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            loop_expression 
                            option(loop_label) loop_switch 
                                               predicate_loop_expression 
                                               WHILE expression block_expression 
                                                     exprs_with_block 
                                                     (?)

** In state 465, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 465, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 462.
** Token involved: POUND
** This state is reached from program after reading:

POUND LBRACK simple_path EQ outer_attr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            (?)

** In state 462, looking ahead at POUND, reducing production
** nonempty_list(outer_attr) -> outer_attr
** is permitted because of the following sub-derivation:

nonempty_list(outer_attr) exprs_without_block // lookahead token appears because exprs_without_block can begin with POUND
outer_attr . 

** In state 462, looking ahead at POUND, shifting is permitted
** because of the following sub-derivation:

nonempty_list(outer_attr) exprs_without_block 
outer_attr nonempty_list(outer_attr) 
           outer_attr 
           . POUND LBRACK attr RBRACK 

** Conflict (shift/reduce) in state 459.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ path_in_expression LPAREN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            struct_expression 
                            path_in_expression LPAREN option(expr_list) RPAREN 
                                                      expr_list 
                                                      separated_nonempty_list(COMMA,expression) 
                                                      expression 
                                                      exprs_with_block 
                                                      (?)

** In state 459, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 459, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce/reduce) in state 458.
** Tokens involved: XOREQ XOR STAREQ STAR SLASHEQ SLASH SHREQ SHR SHLEQ SHL SEMI RPAREN RBRACK RBRACE QUESTION PLUSEQ PLUS PERCENT OROR OREQ OR NE MINUSEQ MINUS LT LPAREN LE LBRACK LBRACE GT GE FATARROW EQEQ EQ ELSE DOTDOTEQ DOTDOT DOT COMMA AS ANDEQ ANDAND AND
** The following explanations concentrate on token LPAREN.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ path_in_expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            (?)

** In state 458, looking ahead at LPAREN, reducing production
** path_expression -> path_in_expression
** is permitted because of the following sub-derivation:

call_expression 
expression LPAREN call_params RPAREN // lookahead token appears
exprs_without_block // lookahead token is inherited
path_expression // lookahead token is inherited
path_in_expression . 

** In state 458, looking ahead at LPAREN, shifting is permitted
** because of the following sub-derivation:

struct_expression 
path_in_expression . LPAREN option(expr_list) RPAREN 

** In state 458, looking ahead at LPAREN, reducing production
** struct_expression -> path_in_expression
** is permitted because of the following sub-derivation:

call_expression 
expression LPAREN call_params RPAREN // lookahead token appears
exprs_without_block // lookahead token is inherited
struct_expression // lookahead token is inherited
path_in_expression . 

** Conflict (shift/reduce) in state 451.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ AMPMUT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            AMPMUT expression 
                                   exprs_with_block 
                                   (?)

** In state 451, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 451, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 450.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ AND

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            AND expression 
                                exprs_with_block 
                                (?)

** In state 450, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 450, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 449.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ ASYNC OR option(closure_params) OR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            ASYNC OR option(closure_params) OR expr_or_typ_block 
                                                               expression 
                                                               exprs_with_block 
                                                               (?)

** In state 449, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 449, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 445.
** Tokens involved: STAR OR MINUS LT LPAREN LBRACK LBRACE DOTDOTEQ DOTDOT AND
** The following explanations concentrate on token LBRACE.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ BREAK option(LIFETIME_OR_LABEL)

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            break_expression 
                            BREAK option(LIFETIME_OR_LABEL) option(expression) 
                                                            expression 
                                                            exprs_with_block 
                                                            (?)

** In state 445, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 445, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 444.
** Token involved: LIFETIME_OR_LABEL
** This state is reached from program after reading:

POUND LBRACK simple_path EQ BREAK

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            break_expression 
                            (?)

** In state 444, looking ahead at LIFETIME_OR_LABEL, reducing production
** option(LIFETIME_OR_LABEL) ->
** is permitted because of the following sub-derivation:

BREAK option(LIFETIME_OR_LABEL) option(expression) // lookahead token appears because option(expression) can begin with LIFETIME_OR_LABEL
      . 

** In state 444, looking ahead at LIFETIME_OR_LABEL, shifting is permitted
** because of the following sub-derivation:

BREAK option(LIFETIME_OR_LABEL) option(expression) 
      . LIFETIME_OR_LABEL 

** Conflict (shift/reduce) in state 438.
** Tokens involved: STAR OR MINUS LT LPAREN LBRACK LBRACE DOTDOTEQ DOTDOT AND
** The following explanations concentrate on token STAR.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ DOTDOT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            (?)

** In state 438, looking ahead at STAR, shifting is permitted
** because of the following sub-derivation:

range_expression 
DOTDOT expression 
       exprs_without_block 
       operator_expression 
       . STAR expression 

** In state 438, looking ahead at STAR, reducing production
** range_expression -> DOTDOT
** is permitted because of the following sub-derivation:

operator_expression 
expression STAR expression // lookahead token appears
exprs_without_block // lookahead token is inherited
range_expression // lookahead token is inherited
DOTDOT . 

** Conflict (shift/reduce) in state 437.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ DOTDOTEQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            range_expression 
                            DOTDOTEQ expression 
                                     exprs_with_block 
                                     (?)

** In state 437, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 437, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 436.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ IF LET pattern EQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            if_let_expression 
                            IF LET pattern EQ expression block_expression else_opt 
                                              exprs_with_block 
                                              (?)

** In state 436, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 436, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 433.
** Tokens involved: RAW_IDENT INT_LIT IDENT FLOAT_LIT
** The following explanations concentrate on token RAW_IDENT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ IF LET OR pattern_no_top_alt OR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            if_let_expression 
                            IF LET pattern EQ expression block_expression else_opt 
                                   OR separated_nonempty_list(OR,pattern_no_top_alt) 
                                      pattern_no_top_alt OR separated_nonempty_list(OR,pattern_no_top_alt) 
                                                            pattern_no_top_alt 
                                                            no_range_pattern 
                                                            (?)

** In state 433, looking ahead at RAW_IDENT, shifting is permitted
** because of the following sub-derivation:

identifier_pattern 
ident option(pat_at) 
. RAW_IDENT 

** In state 433, looking ahead at RAW_IDENT, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

struct_pattern 
path_in_expression LBRACK option(struct_pattern_elements) RBRACK 
option(PATHSEP) separated_nonempty_list(PATHSEP,path_expr_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,path_expr_segment) can begin with RAW_IDENT
. 

** Conflict (reduce/reduce) in state 408.
** Tokens involved: RPAREN RBRACK OR IN IF FATARROW EQ COMMA COLON
** The following explanations concentrate on token OR.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR list(outer_attr) ANDAND MUT ident option(pat_at)

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block // lookahead token appears
                               closure_params // lookahead token is inherited
                               nonempty_separated_or_terminated_list(COMMA,closure_param) // lookahead token is inherited
                               separated_nonempty_list(COMMA,closure_param) // lookahead token is inherited
                               closure_param // lookahead token is inherited
                               list(outer_attr) pattern_no_top_alt option(typ_opt) // lookahead token is inherited because option(typ_opt) can vanish
                                                no_range_pattern // lookahead token is inherited
                                                (?)

** In state 408, looking ahead at OR, reducing production
** identifier_pattern -> MUT ident option(pat_at)
** is permitted because of the following sub-derivation:

ANDAND no_range_pattern // lookahead token is inherited
       identifier_pattern // lookahead token is inherited
       MUT ident option(pat_at) . 

** In state 408, looking ahead at OR, reducing production
** identifier_pattern -> ident option(pat_at)
** is permitted because of the following sub-derivation:

ANDAND MUT no_range_pattern // lookahead token is inherited
           identifier_pattern // lookahead token is inherited
           ident option(pat_at) . 

** Conflict (shift/reduce) in state 377.
** Token involved: COMMA
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR list(outer_attr) path_in_expression LBRACK struct_pattern_field

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                               closure_params 
                               nonempty_separated_or_terminated_list(COMMA,closure_param) 
                               nonempty_list(terminated(closure_param,COMMA)) 
                               closure_param COMMA 
                               list(outer_attr) pattern_no_top_alt option(typ_opt) 
                                                no_range_pattern 
                                                struct_pattern 
                                                path_in_expression LBRACK option(struct_pattern_elements) RBRACK 
                                                                          struct_pattern_elements 
                                                                          (?)

** In state 377, looking ahead at COMMA, reducing production
** separated_nonempty_list(COMMA,struct_pattern_field) -> struct_pattern_field
** is permitted because of the following sub-derivation:

struct_pattern_fields COMMA struct_pattern_etcetara // lookahead token appears
separated_nonempty_list(COMMA,struct_pattern_field) // lookahead token is inherited
struct_pattern_field . 

** In state 377, looking ahead at COMMA, shifting is permitted
** because of the following sub-derivation:

struct_pattern_fields COMMA struct_pattern_etcetara 
separated_nonempty_list(COMMA,struct_pattern_field) 
struct_pattern_field . COMMA separated_nonempty_list(COMMA,struct_pattern_field) 

** Conflict (reduce/reduce) in state 361.
** Token involved: RPAREN
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR list(outer_attr) path_in_expression LPAREN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                               closure_params 
                               nonempty_separated_or_terminated_list(COMMA,closure_param) 
                               nonempty_list(terminated(closure_param,COMMA)) 
                               closure_param COMMA 
                               list(outer_attr) pattern_no_top_alt option(typ_opt) 
                                                no_range_pattern 
                                                tuple_struct_pattern 
                                                path_in_expression LPAREN tuple_struct_items RPAREN // lookahead token appears
                                                                          separated_or_terminated_list(COMMA,pattern) // lookahead token is inherited
                                                                          (?)

** In state 361, looking ahead at RPAREN, reducing production
** list(terminated(pattern,COMMA)) ->
** is permitted because of the following sub-derivation:

list(terminated(pattern,COMMA)) // lookahead token is inherited
. 

** In state 361, looking ahead at RPAREN, reducing production
** loption(separated_nonempty_list(COMMA,pattern)) ->
** is permitted because of the following sub-derivation:

loption(separated_nonempty_list(COMMA,pattern)) // lookahead token is inherited
. 

** Conflict (shift/reduce) in state 356.
** Tokens involved: RAW_IDENT IDENT
** The following explanations concentrate on token RAW_IDENT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR list(outer_attr) AND MUT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                               closure_params 
                               nonempty_separated_or_terminated_list(COMMA,closure_param) 
                               nonempty_list(terminated(closure_param,COMMA)) 
                               closure_param COMMA 
                               list(outer_attr) pattern_no_top_alt option(typ_opt) 
                                                no_range_pattern 
                                                AND MUT no_range_pattern 
                                                        (?)

** In state 356, looking ahead at RAW_IDENT, shifting is permitted
** because of the following sub-derivation:

identifier_pattern 
ident option(pat_at) 
. RAW_IDENT 

** In state 356, looking ahead at RAW_IDENT, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

struct_pattern 
path_in_expression LBRACK option(struct_pattern_elements) RBRACK 
option(PATHSEP) separated_nonempty_list(PATHSEP,path_expr_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,path_expr_segment) can begin with RAW_IDENT
. 

** Conflict (shift/reduce) in state 355.
** Tokens involved: RAW_IDENT IDENT
** The following explanations concentrate on token RAW_IDENT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR list(outer_attr) AND

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                               closure_params 
                               nonempty_separated_or_terminated_list(COMMA,closure_param) 
                               nonempty_list(terminated(closure_param,COMMA)) 
                               closure_param COMMA 
                               list(outer_attr) pattern_no_top_alt option(typ_opt) 
                                                no_range_pattern 
                                                AND no_range_pattern 
                                                    (?)

** In state 355, looking ahead at RAW_IDENT, shifting is permitted
** because of the following sub-derivation:

identifier_pattern 
ident option(pat_at) 
. RAW_IDENT 

** In state 355, looking ahead at RAW_IDENT, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

struct_pattern 
path_in_expression LBRACK option(struct_pattern_elements) RBRACK 
option(PATHSEP) separated_nonempty_list(PATHSEP,path_expr_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,path_expr_segment) can begin with RAW_IDENT
. 

** Conflict (shift/reduce) in state 352.
** Tokens involved: RAW_IDENT IDENT
** The following explanations concentrate on token RAW_IDENT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR list(outer_attr) ANDAND MUT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                               closure_params 
                               nonempty_separated_or_terminated_list(COMMA,closure_param) 
                               nonempty_list(terminated(closure_param,COMMA)) 
                               closure_param COMMA 
                               list(outer_attr) pattern_no_top_alt option(typ_opt) 
                                                no_range_pattern 
                                                ANDAND MUT no_range_pattern 
                                                           (?)

** In state 352, looking ahead at RAW_IDENT, shifting is permitted
** because of the following sub-derivation:

identifier_pattern 
ident option(pat_at) 
. RAW_IDENT 

** In state 352, looking ahead at RAW_IDENT, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

struct_pattern 
path_in_expression LBRACK option(struct_pattern_elements) RBRACK 
option(PATHSEP) separated_nonempty_list(PATHSEP,path_expr_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,path_expr_segment) can begin with RAW_IDENT
. 

** Conflict (shift/reduce) in state 351.
** Tokens involved: RAW_IDENT IDENT
** The following explanations concentrate on token RAW_IDENT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR list(outer_attr) ANDAND

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                               closure_params 
                               nonempty_separated_or_terminated_list(COMMA,closure_param) 
                               nonempty_list(terminated(closure_param,COMMA)) 
                               closure_param COMMA 
                               list(outer_attr) pattern_no_top_alt option(typ_opt) 
                                                no_range_pattern 
                                                ANDAND no_range_pattern 
                                                       (?)

** In state 351, looking ahead at RAW_IDENT, shifting is permitted
** because of the following sub-derivation:

identifier_pattern 
ident option(pat_at) 
. RAW_IDENT 

** In state 351, looking ahead at RAW_IDENT, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

struct_pattern 
path_in_expression LBRACK option(struct_pattern_elements) RBRACK 
option(PATHSEP) separated_nonempty_list(PATHSEP,path_expr_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,path_expr_segment) can begin with RAW_IDENT
. 

** Conflict (shift/reduce) in state 334.
** Token involved: PATHSEP
** This state is reached from program after reading:

POUND LBRACK simple_path EQ qualified_path_type path_ident_segment

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                                                (?)

** In state 334, looking ahead at PATHSEP, reducing production
** option(path_genarg) ->
** is permitted because of the following sub-derivation:

path_expr_segment PATHSEP separated_nonempty_list(PATHSEP,path_expr_segment) // lookahead token appears
path_ident_segment option(path_genarg) // lookahead token is inherited
                   . 

** In state 334, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

path_expr_segment 
path_ident_segment option(path_genarg) 
                   path_genarg 
                   . PATHSEP generic_args 

** Conflict (shift/reduce) in state 311.
** Token involved: RPAREN
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR list(outer_attr) LPAREN pattern

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                               closure_params 
                               nonempty_separated_or_terminated_list(COMMA,closure_param) 
                               nonempty_list(terminated(closure_param,COMMA)) 
                               closure_param COMMA 
                               list(outer_attr) pattern_no_top_alt option(typ_opt) 
                                                no_range_pattern 
                                                (?)

** In state 311, looking ahead at RPAREN, shifting is permitted
** because of the following sub-derivation:

LPAREN pattern . RPAREN 

** In state 311, looking ahead at RPAREN, reducing production
** separated_nonempty_list(COMMA,pattern) -> pattern
** is permitted because of the following sub-derivation:

tuple_pattern 
LPAREN option(tuple_pattern_items) RPAREN // lookahead token appears
       tuple_pattern_items // lookahead token is inherited
       separated_nonempty_list(COMMA,pattern) // lookahead token is inherited
       pattern . 

** Conflict (shift/reduce) in state 304.
** Tokens involved: INT_LIT FLOAT_LIT
** The following explanations concentrate on token INT_LIT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR list(outer_attr) MINUS

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                               closure_params 
                               nonempty_separated_or_terminated_list(COMMA,closure_param) 
                               nonempty_list(terminated(closure_param,COMMA)) 
                               closure_param COMMA 
                               list(outer_attr) pattern_no_top_alt option(typ_opt) 
                                                (?)

** In state 304, looking ahead at INT_LIT, reducing production
** neg -> MINUS
** is permitted because of the following sub-derivation:

no_range_pattern 
literal_pattern 
neg INT_LIT // lookahead token appears
MINUS . 

** In state 304, looking ahead at INT_LIT, shifting is permitted
** because of the following sub-derivation:

range_pattern 
range_inclusive_pattern 
range_pattern_bound DOTDOTEQ range_pattern_bound 
MINUS . INT_LIT 

** Conflict (shift/reduce) in state 296.
** Tokens involved: RAW_IDENT INT_LIT IDENT FLOAT_LIT
** The following explanations concentrate on token RAW_IDENT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR list(outer_attr) ident AT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                               closure_params 
                               nonempty_separated_or_terminated_list(COMMA,closure_param) 
                               nonempty_list(terminated(closure_param,COMMA)) 
                               closure_param COMMA 
                               list(outer_attr) pattern_no_top_alt option(typ_opt) 
                                                no_range_pattern 
                                                identifier_pattern 
                                                ident option(pat_at) 
                                                      pat_at 
                                                      AT pattern_no_top_alt 
                                                         no_range_pattern 
                                                         (?)

** In state 296, looking ahead at RAW_IDENT, shifting is permitted
** because of the following sub-derivation:

identifier_pattern 
ident option(pat_at) 
. RAW_IDENT 

** In state 296, looking ahead at RAW_IDENT, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

struct_pattern 
path_in_expression LBRACK option(struct_pattern_elements) RBRACK 
option(PATHSEP) separated_nonempty_list(PATHSEP,path_expr_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,path_expr_segment) can begin with RAW_IDENT
. 

** Conflict (shift/reduce) in state 289.
** Tokens involved: RAW_IDENT INT_LIT IDENT FLOAT_LIT
** The following explanations concentrate on token RAW_IDENT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ IF LET OR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            if_let_expression 
                            IF LET pattern EQ expression block_expression else_opt 
                                   OR separated_nonempty_list(OR,pattern_no_top_alt) 
                                      pattern_no_top_alt 
                                      no_range_pattern 
                                      (?)

** In state 289, looking ahead at RAW_IDENT, shifting is permitted
** because of the following sub-derivation:

identifier_pattern 
ident option(pat_at) 
. RAW_IDENT 

** In state 289, looking ahead at RAW_IDENT, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

struct_pattern 
path_in_expression LBRACK option(struct_pattern_elements) RBRACK 
option(PATHSEP) separated_nonempty_list(PATHSEP,path_expr_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,path_expr_segment) can begin with RAW_IDENT
. 

** Conflict (shift/reduce) in state 287.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ IF

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            if_expression 
                            IF expression block_expression else_opt 
                               exprs_with_block 
                               (?)

** In state 287, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 287, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 286.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACK

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            array_expression 
                            LBRACK array_elements RBRACK 
                                   expression SEMI expression 
                                   exprs_with_block 
                                   (?)

** In state 286, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 286, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 283.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LPAREN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            grouped_expression 
                            LPAREN expression RPAREN 
                                   exprs_with_block 
                                   (?)

** In state 283, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 283, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 282.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ MATCH

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            match_expression 
                            MATCH scrutinee LBRACE list(inner_attr) option(match_arms) RBRACE 
                                  expression 
                                  exprs_with_block 
                                  (?)

** In state 282, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 282, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 281.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ MINUS

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            MINUS expression 
                                  exprs_with_block 
                                  (?)

** In state 281, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 281, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 280.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ MOVE OR option(closure_params) OR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            MOVE OR option(closure_params) OR expr_or_typ_block 
                                                              expression 
                                                              exprs_with_block 
                                                              (?)

** In state 280, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 280, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 276.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ NOT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            NOT expression 
                                exprs_with_block 
                                (?)

** In state 276, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 276, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 275.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT LBRACK typ SEMI

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               LBRACK typ SEMI expression RBRACK 
                                               exprs_with_block 
                                               (?)

** In state 275, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 275, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (reduce/reduce) in state 273.
** Tokens involved: TRUE STRING_LIT SEMI RPAREN RBRACK RAW_STRING_LIT RAW_IDENT RAW_C_STRING RAW_BYTE_STRING OR INT_LIT IDENT GT FLOAT_LIT FALSE EQ C_STRING COMMA CHAR_LIT BYTE_STRING BYTE AS
** The following explanations concentrate on token GT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT IMPL trait_bound

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT // lookahead token appears because option(as_typath) can vanish
                               (?)

** In state 273, looking ahead at GT, reducing production
** impl_trait_type_one_bound -> IMPL trait_bound
** is permitted because of the following sub-derivation:

type_no_bounds // lookahead token is inherited
impl_trait_type_one_bound // lookahead token is inherited
IMPL trait_bound . 

** In state 273, looking ahead at GT, reducing production
** type_param_bound -> trait_bound
** is permitted because of the following sub-derivation:

impl_trait_type // lookahead token is inherited
IMPL type_param_bounds // lookahead token is inherited
     nonempty_separated_or_terminated_list(PLUS,type_param_bound) // lookahead token is inherited
     separated_nonempty_list(PLUS,type_param_bound) // lookahead token is inherited
     type_param_bound // lookahead token is inherited
     trait_bound . 

** Conflict (shift/reduce) in state 257.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT FOR LT list(outer_attr) ident EQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               trait_bound 
                               option(question_or_for) type_path 
                               for_lifetimes 
                               FOR generic_params 
                                   LT separated_nonempty_list(COMMA,generic_param) GT 
                                      generic_param 
                                      list(outer_attr) type_param 
                                                       ident option(eq_typ) 
                                                             eq_typ 
                                                             EQ typ 
                                                                type_no_bounds 
                                                                (?)

** In state 257, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) 
. PATHSEP 

** In state 257, looking ahead at PATHSEP, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

trait_bound 
option(question_or_for) type_path // lookahead token appears because type_path can begin with PATHSEP
. 

** Conflict (shift/reduce) in state 256.
** Tokens involved: GT EQ COMMA
** The following explanations concentrate on token EQ.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT FOR LT list(outer_attr) ident

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               trait_bound 
                               option(question_or_for) type_path 
                               for_lifetimes 
                               FOR generic_params 
                                   LT separated_nonempty_list(COMMA,generic_param) GT 
                                      generic_param 
                                      list(outer_attr) type_param 
                                                       (?)

** In state 256, looking ahead at EQ, shifting is permitted
** because of the following sub-derivation:

ident option(eq_typ) 
      eq_typ 
      . EQ typ 

** In state 256, looking ahead at EQ, reducing production
** option(type_param_bounds) ->
** is permitted because of the following sub-derivation:

ident option(type_param_bounds) option(eq_typ) // lookahead token appears because option(eq_typ) can begin with EQ
      . 

** Conflict (reduce/reduce) in state 245.
** Tokens involved: GT COMMA
** The following explanations concentrate on token GT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT FOR LT list(outer_attr) lifetime COLON

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               trait_bound 
                               option(question_or_for) type_path 
                               for_lifetimes 
                               FOR generic_params 
                                   LT separated_nonempty_list(COMMA,generic_param) GT // lookahead token appears
                                      generic_param // lookahead token is inherited
                                      list(outer_attr) lifetime_param // lookahead token is inherited
                                                       lifetime COLON option(lifetime_bounds) // lookahead token is inherited
                                                                      (?)

** In state 245, looking ahead at GT, reducing production
** list(terminated(lifetime,PLUS)) ->
** is permitted because of the following sub-derivation:

lifetime_bounds // lookahead token is inherited
separated_or_terminated_list(PLUS,lifetime) // lookahead token is inherited
list(terminated(lifetime,PLUS)) // lookahead token is inherited
. 

** In state 245, looking ahead at GT, reducing production
** loption(separated_nonempty_list(PLUS,lifetime)) ->
** is permitted because of the following sub-derivation:

lifetime_bounds // lookahead token is inherited
separated_or_terminated_list(PLUS,lifetime) // lookahead token is inherited
loption(separated_nonempty_list(PLUS,lifetime)) // lookahead token is inherited
. 

** In state 245, looking ahead at GT, reducing production
** option(lifetime_bounds) ->
** is permitted because of the following sub-derivation:

. 

** Conflict (reduce/reduce) in state 234.
** Tokens involved: TRUE STRING_LIT SEMI RPAREN RBRACK RAW_STRING_LIT RAW_IDENT RAW_C_STRING RAW_BYTE_STRING OR INT_LIT IDENT GT FLOAT_LIT FALSE EQ C_STRING COMMA CHAR_LIT BYTE_STRING BYTE AS
** The following explanations concentrate on token GT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT DYN trait_bound

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT // lookahead token appears because option(as_typath) can vanish
                               (?)

** In state 234, looking ahead at GT, reducing production
** type_no_bounds -> DYN trait_bound
** is permitted because of the following sub-derivation:

type_no_bounds // lookahead token is inherited
DYN trait_bound . 

** In state 234, looking ahead at GT, reducing production
** type_param_bound -> trait_bound
** is permitted because of the following sub-derivation:

trait_object_type // lookahead token is inherited
DYN type_param_bounds // lookahead token is inherited
    nonempty_separated_or_terminated_list(PLUS,type_param_bound) // lookahead token is inherited
    separated_nonempty_list(PLUS,type_param_bound) // lookahead token is inherited
    type_param_bound // lookahead token is inherited
    trait_bound . 

** Conflict (shift/reduce) in state 224.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT qualified_path_type path_ident_segment option(PATHSEP) LPAREN option(type_path_fn_inputs) RPAREN RARROW

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               qualified_path_in_type 
                               qualified_path_type separated_nonempty_list(PATHSEP,type_path_segment) 
                                                   type_path_segment 
                                                   path_ident_segment option(path_gen_path_fn) 
                                                                      path_gen_path_fn 
                                                                      option(PATHSEP) type_path_fn 
                                                                                      LPAREN option(type_path_fn_inputs) RPAREN option(rarrow_no_bounds) 
                                                                                                                                rarrow_no_bounds 
                                                                                                                                RARROW type_no_bounds 
                                                                                                                                       (?)

** In state 224, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) 
. PATHSEP 

** In state 224, looking ahead at PATHSEP, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

trait_bound 
option(question_or_for) type_path // lookahead token appears because type_path can begin with PATHSEP
. 

** Conflict (shift/reduce) in state 218.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT qualified_path_type path_ident_segment option(PATHSEP) LPAREN typ COMMA

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               qualified_path_in_type 
                               qualified_path_type separated_nonempty_list(PATHSEP,type_path_segment) 
                                                   type_path_segment 
                                                   path_ident_segment option(path_gen_path_fn) 
                                                                      path_gen_path_fn 
                                                                      option(PATHSEP) type_path_fn 
                                                                                      LPAREN option(type_path_fn_inputs) RPAREN option(rarrow_no_bounds) 
                                                                                             type_path_fn_inputs 
                                                                                             nonempty_separated_or_terminated_list(COMMA,typ) 
                                                                                             nonempty_list(terminated(typ,COMMA)) 
                                                                                             typ COMMA nonempty_list(terminated(typ,COMMA)) 
                                                                                                       typ COMMA 
                                                                                                       type_no_bounds 
                                                                                                       (?)

** In state 218, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) 
. PATHSEP 

** In state 218, looking ahead at PATHSEP, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

trait_bound 
option(question_or_for) type_path // lookahead token appears because type_path can begin with PATHSEP
. 

** Conflict (shift/reduce) in state 215.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT qualified_path_type path_ident_segment option(PATHSEP) LPAREN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               qualified_path_in_type 
                               qualified_path_type separated_nonempty_list(PATHSEP,type_path_segment) 
                                                   type_path_segment 
                                                   path_ident_segment option(path_gen_path_fn) 
                                                                      path_gen_path_fn 
                                                                      option(PATHSEP) type_path_fn 
                                                                                      LPAREN option(type_path_fn_inputs) RPAREN option(rarrow_no_bounds) 
                                                                                             type_path_fn_inputs 
                                                                                             nonempty_separated_or_terminated_list(COMMA,typ) 
                                                                                             nonempty_list(terminated(typ,COMMA)) 
                                                                                             typ COMMA 
                                                                                             type_no_bounds 
                                                                                             (?)

** In state 215, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) 
. PATHSEP 

** In state 215, looking ahead at PATHSEP, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

trait_bound 
option(question_or_for) type_path // lookahead token appears because type_path can begin with PATHSEP
. 

** Conflict (shift/reduce/reduce) in state 211.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token SUPER.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ qualified_path_type path_ident_segment PATHSEP LT generic_arg COMMA

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                                                path_expr_segment 
                                                path_ident_segment option(path_genarg) 
                                                                   path_genarg 
                                                                   PATHSEP generic_args 
                                                                           LT separated_or_terminated_list(COMMA,generic_arg) GT 
                                                                              list(terminated(generic_arg,COMMA)) 
                                                                              generic_arg COMMA list(terminated(generic_arg,COMMA)) 
                                                                                                generic_arg COMMA list(terminated(generic_arg,COMMA)) 
                                                                                                (?)

** In state 211, looking ahead at SUPER, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

typ 
type_no_bounds 
type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,type_path_segment) can begin with SUPER
. 

** In state 211, looking ahead at SUPER, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

typ 
type_no_bounds 
trait_bound 
option(question_or_for) type_path // lookahead token appears because type_path can begin with SUPER
. 

** In state 211, looking ahead at SUPER, shifting is permitted
** because of the following sub-derivation:

generic_args_const 
simple_path_segment 
. SUPER 

** Conflict (reduce/reduce) in state 204.
** Tokens involved: GT COMMA
** The following explanations concentrate on token GT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ qualified_path_type path_ident_segment PATHSEP LT ident option(generic_args) EQ type_param_bounds

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                                                path_expr_segment 
                                                path_ident_segment option(path_genarg) 
                                                                   path_genarg 
                                                                   PATHSEP generic_args 
                                                                           LT separated_or_terminated_list(COMMA,generic_arg) GT // lookahead token appears
                                                                              loption(separated_nonempty_list(COMMA,generic_arg)) // lookahead token is inherited
                                                                              separated_nonempty_list(COMMA,generic_arg) // lookahead token is inherited
                                                                              generic_arg // lookahead token is inherited
                                                                              (?)

** In state 204, looking ahead at GT, reducing production
** generic_args_bounds -> ident option(generic_args) EQ type_param_bounds
** is permitted because of the following sub-derivation:

generic_args_bounds // lookahead token is inherited
ident option(generic_args) EQ type_param_bounds . 

** In state 204, looking ahead at GT, reducing production
** trait_object_type -> type_param_bounds
** is permitted because of the following sub-derivation:

generic_args_binding // lookahead token is inherited
ident option(generic_args) EQ typ // lookahead token is inherited
                              trait_object_type // lookahead token is inherited
                              type_param_bounds . 

** Conflict (shift/reduce) in state 203.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ qualified_path_type path_ident_segment PATHSEP LT ident option(generic_args) EQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                                                path_expr_segment 
                                                path_ident_segment option(path_genarg) 
                                                                   path_genarg 
                                                                   PATHSEP generic_args 
                                                                           LT separated_or_terminated_list(COMMA,generic_arg) GT 
                                                                              list(terminated(generic_arg,COMMA)) 
                                                                              generic_arg COMMA list(terminated(generic_arg,COMMA)) 
                                                                              generic_args_binding 
                                                                              ident option(generic_args) EQ typ 
                                                                                                            type_no_bounds 
                                                                                                            (?)

** In state 203, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) 
. PATHSEP 

** In state 203, looking ahead at PATHSEP, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

trait_bound 
option(question_or_for) type_path // lookahead token appears because type_path can begin with PATHSEP
. 

** Conflict (reduce/reduce) in state 200.
** Tokens involved: GT COMMA
** The following explanations concentrate on token GT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ qualified_path_type path_ident_segment PATHSEP LT lifetime

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                                                path_expr_segment 
                                                path_ident_segment option(path_genarg) 
                                                                   path_genarg 
                                                                   PATHSEP generic_args 
                                                                           LT separated_or_terminated_list(COMMA,generic_arg) GT // lookahead token appears
                                                                              loption(separated_nonempty_list(COMMA,generic_arg)) // lookahead token is inherited
                                                                              separated_nonempty_list(COMMA,generic_arg) // lookahead token is inherited
                                                                              generic_arg // lookahead token is inherited
                                                                              (?)

** In state 200, looking ahead at GT, reducing production
** generic_arg -> lifetime
** is permitted because of the following sub-derivation:

lifetime . 

** In state 200, looking ahead at GT, reducing production
** type_param_bound -> lifetime
** is permitted because of the following sub-derivation:

typ // lookahead token is inherited
trait_object_type // lookahead token is inherited
type_param_bounds // lookahead token is inherited
nonempty_separated_or_terminated_list(PLUS,type_param_bound) // lookahead token is inherited
separated_nonempty_list(PLUS,type_param_bound) // lookahead token is inherited
type_param_bound // lookahead token is inherited
lifetime . 

** Conflict (shift/reduce) in state 183.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT option(for_lifetimes) function_type_qualifiers FN LPAREN list(outer_attr) ident COLON

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               bare_function_type 
                               option(for_lifetimes) function_type_qualifiers FN LPAREN option(function_parameters_maybe_named_variadic) RPAREN option(bare_function_return_type) 
                                                                                        function_parameters_maybe_named_variadic 
                                                                                        maybe_named_function_parameters_variadic 
                                                                                        nonempty_list(terminated(maybe_named_param,COMMA)) list(outer_attr) DOTDOTDOT 
                                                                                        maybe_named_param COMMA 
                                                                                        list(outer_attr) ident COLON typ 
                                                                                                                     type_no_bounds 
                                                                                                                     (?)

** In state 183, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) 
. PATHSEP 

** In state 183, looking ahead at PATHSEP, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

trait_bound 
option(question_or_for) type_path // lookahead token appears because type_path can begin with PATHSEP
. 

** Conflict (reduce/reduce) in state 175.
** Tokens involved: TRUE STRING_LIT SEMI RPAREN RBRACK RAW_STRING_LIT RAW_IDENT RAW_C_STRING RAW_BYTE_STRING OR INT_LIT IDENT GT FLOAT_LIT FALSE EQ C_STRING COMMA CHAR_LIT BYTE_STRING BYTE AS
** The following explanations concentrate on token GT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT trait_bound

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT // lookahead token appears because option(as_typath) can vanish
                               (?)

** In state 175, looking ahead at GT, reducing production
** type_no_bounds -> trait_bound
** is permitted because of the following sub-derivation:

type_no_bounds // lookahead token is inherited
trait_bound . 

** In state 175, looking ahead at GT, reducing production
** type_param_bound -> trait_bound
** is permitted because of the following sub-derivation:

trait_object_type // lookahead token is inherited
type_param_bounds // lookahead token is inherited
nonempty_separated_or_terminated_list(PLUS,type_param_bound) // lookahead token is inherited
separated_nonempty_list(PLUS,type_param_bound) // lookahead token is inherited
type_param_bound // lookahead token is inherited
trait_bound . 

** Conflict (shift/reduce) in state 170.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT option(for_lifetimes) function_type_qualifiers FN LPAREN list(outer_attr) UNDERSCORE COLON

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               bare_function_type 
                               option(for_lifetimes) function_type_qualifiers FN LPAREN option(function_parameters_maybe_named_variadic) RPAREN option(bare_function_return_type) 
                                                                                        function_parameters_maybe_named_variadic 
                                                                                        maybe_named_function_parameters_variadic 
                                                                                        nonempty_list(terminated(maybe_named_param,COMMA)) list(outer_attr) DOTDOTDOT 
                                                                                        maybe_named_param COMMA 
                                                                                        list(outer_attr) UNDERSCORE COLON typ 
                                                                                                                          type_no_bounds 
                                                                                                                          (?)

** In state 170, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) 
. PATHSEP 

** In state 170, looking ahead at PATHSEP, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

trait_bound 
option(question_or_for) type_path // lookahead token appears because type_path can begin with PATHSEP
. 

** Conflict (shift/reduce/reduce) in state 168.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token RAW_IDENT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT option(for_lifetimes) function_type_qualifiers FN LPAREN list(outer_attr)

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               bare_function_type 
                               option(for_lifetimes) function_type_qualifiers FN LPAREN option(function_parameters_maybe_named_variadic) RPAREN option(bare_function_return_type) 
                                                                                        function_parameters_maybe_named_variadic 
                                                                                        maybe_named_function_parameters_variadic 
                                                                                        nonempty_list(terminated(maybe_named_param,COMMA)) list(outer_attr) DOTDOTDOT 
                                                                                        maybe_named_param COMMA 
                                                                                        (?)

** In state 168, looking ahead at RAW_IDENT, shifting is permitted
** because of the following sub-derivation:

list(outer_attr) ident COLON typ 
                 . RAW_IDENT 

** In state 168, looking ahead at RAW_IDENT, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

list(outer_attr) typ 
                 type_no_bounds 
                 type_path 
                 option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,type_path_segment) can begin with RAW_IDENT
                 . 

** In state 168, looking ahead at RAW_IDENT, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

list(outer_attr) typ 
                 type_no_bounds 
                 trait_bound 
                 option(question_or_for) type_path // lookahead token appears because type_path can begin with RAW_IDENT
                 . 

** Conflict (shift/reduce) in state 164.
** Token involved: POUND
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT option(for_lifetimes) function_type_qualifiers FN LPAREN maybe_named_param COMMA

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               bare_function_type 
                               option(for_lifetimes) function_type_qualifiers FN LPAREN option(function_parameters_maybe_named_variadic) RPAREN option(bare_function_return_type) 
                                                                                        function_parameters_maybe_named_variadic 
                                                                                        maybe_named_function_parameters_variadic 
                                                                                        (?)

** In state 164, looking ahead at POUND, reducing production
** nonempty_list(terminated(maybe_named_param,COMMA)) -> maybe_named_param COMMA
** is permitted because of the following sub-derivation:

nonempty_list(terminated(maybe_named_param,COMMA)) list(outer_attr) DOTDOTDOT // lookahead token appears because list(outer_attr) can begin with POUND
maybe_named_param COMMA . 

** In state 164, looking ahead at POUND, shifting is permitted
** because of the following sub-derivation:

nonempty_list(terminated(maybe_named_param,COMMA)) list(outer_attr) DOTDOTDOT 
maybe_named_param COMMA nonempty_list(terminated(maybe_named_param,COMMA)) 
                        maybe_named_param COMMA 
                        list(outer_attr) ident COLON typ 
                        outer_attr list(outer_attr) 
                        . POUND LBRACK attr RBRACK 

** Conflict (shift/reduce) in state 153.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT option(for_lifetimes) function_type_qualifiers FN LPAREN option(function_parameters_maybe_named_variadic) RPAREN RARROW

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               bare_function_type 
                               option(for_lifetimes) function_type_qualifiers FN LPAREN option(function_parameters_maybe_named_variadic) RPAREN option(bare_function_return_type) 
                                                                                                                                                bare_function_return_type 
                                                                                                                                                RARROW type_no_bounds 
                                                                                                                                                       (?)

** In state 153, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) 
. PATHSEP 

** In state 153, looking ahead at PATHSEP, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

trait_bound 
option(question_or_for) type_path // lookahead token appears because type_path can begin with PATHSEP
. 

** Conflict (reduce/reduce) in state 148.
** Token involved: RPAREN
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT option(for_lifetimes) function_type_qualifiers FN LPAREN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               bare_function_type 
                               option(for_lifetimes) function_type_qualifiers FN LPAREN option(function_parameters_maybe_named_variadic) RPAREN option(bare_function_return_type) // lookahead token appears
                                                                                        (?)

** In state 148, looking ahead at RPAREN, reducing production
** list(terminated(maybe_named_param,COMMA)) ->
** is permitted because of the following sub-derivation:

function_parameters_maybe_named_variadic // lookahead token is inherited
maybe_named_function_parameters // lookahead token is inherited
separated_or_terminated_list(COMMA,maybe_named_param) // lookahead token is inherited
list(terminated(maybe_named_param,COMMA)) // lookahead token is inherited
. 

** In state 148, looking ahead at RPAREN, reducing production
** loption(separated_nonempty_list(COMMA,maybe_named_param)) ->
** is permitted because of the following sub-derivation:

function_parameters_maybe_named_variadic // lookahead token is inherited
maybe_named_function_parameters // lookahead token is inherited
separated_or_terminated_list(COMMA,maybe_named_param) // lookahead token is inherited
loption(separated_nonempty_list(COMMA,maybe_named_param)) // lookahead token is inherited
. 

** In state 148, looking ahead at RPAREN, reducing production
** option(function_parameters_maybe_named_variadic) ->
** is permitted because of the following sub-derivation:

. 

** Conflict (shift/reduce) in state 118.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT AND option(lifetime) MUT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               reference_type 
                               AND option(lifetime) MUT type_no_bounds 
                                                        (?)

** In state 118, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) 
. PATHSEP 

** In state 118, looking ahead at PATHSEP, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

trait_bound 
option(question_or_for) type_path // lookahead token appears because type_path can begin with PATHSEP
. 

** Conflict (shift/reduce) in state 117.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT AND option(lifetime)

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               reference_type 
                               AND option(lifetime) type_no_bounds 
                                                    (?)

** In state 117, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) 
. PATHSEP 

** In state 117, looking ahead at PATHSEP, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

trait_bound 
option(question_or_for) type_path // lookahead token appears because type_path can begin with PATHSEP
. 

** Conflict (shift/reduce/reduce) in state 106.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT GT DOLLAR_CRATE CRATE
** The following explanations concentrate on token SUPER.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ qualified_path_type path_ident_segment PATHSEP LT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                                                path_expr_segment 
                                                path_ident_segment option(path_genarg) 
                                                                   path_genarg 
                                                                   PATHSEP generic_args 
                                                                           LT separated_or_terminated_list(COMMA,generic_arg) GT 
                                                                              list(terminated(generic_arg,COMMA)) 
                                                                              generic_arg COMMA list(terminated(generic_arg,COMMA)) 
                                                                              (?)

** In state 106, looking ahead at SUPER, reducing production
** option(PATHSEP) ->
** is permitted because of the following sub-derivation:

typ 
type_no_bounds 
type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) // lookahead token appears because separated_nonempty_list(PATHSEP,type_path_segment) can begin with SUPER
. 

** In state 106, looking ahead at SUPER, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

typ 
type_no_bounds 
trait_bound 
option(question_or_for) type_path // lookahead token appears because type_path can begin with SUPER
. 

** In state 106, looking ahead at SUPER, shifting is permitted
** because of the following sub-derivation:

generic_args_const 
simple_path_segment 
. SUPER 

** Conflict (shift/reduce) in state 102.
** Tokens involved: PATHSEP LT LPAREN
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT qualified_path_type path_ident_segment

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               qualified_path_in_type 
                               qualified_path_type separated_nonempty_list(PATHSEP,type_path_segment) 
                                                   (?)

** In state 102, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path_segment 
path_ident_segment option(path_gen_path_fn) 
                   path_gen_path_fn 
                   option(PATHSEP) generic_args 
                   . PATHSEP 

** In state 102, looking ahead at PATHSEP, reducing production
** option(path_gen_path_fn) ->
** is permitted because of the following sub-derivation:

type_path_segment PATHSEP separated_nonempty_list(PATHSEP,type_path_segment) // lookahead token appears
path_ident_segment option(path_gen_path_fn) // lookahead token is inherited
                   . 

** Conflict (shift/reduce) in state 99.
** Token involved: PATHSEP
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT qualified_path_type path_ident_segment option(PATHSEP) LPAREN option(type_path_fn_inputs) RPAREN RARROW qualified_path_type type_path_segment

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               qualified_path_in_type 
                               qualified_path_type separated_nonempty_list(PATHSEP,type_path_segment) 
                                                   (?)

** In state 99, looking ahead at PATHSEP, reducing production
** separated_nonempty_list(PATHSEP,type_path_segment) -> type_path_segment
** is permitted because of the following sub-derivation:

type_path_segment PATHSEP separated_nonempty_list(PATHSEP,type_path_segment) // lookahead token appears
path_ident_segment option(path_gen_path_fn) // lookahead token is inherited
                   path_gen_path_fn // lookahead token is inherited
                   option(PATHSEP) type_path_fn // lookahead token is inherited
                                   LPAREN option(type_path_fn_inputs) RPAREN option(rarrow_no_bounds) // lookahead token is inherited
                                                                             rarrow_no_bounds // lookahead token is inherited
                                                                             RARROW type_no_bounds // lookahead token is inherited
                                                                                    qualified_path_in_type // lookahead token is inherited
                                                                                    qualified_path_type separated_nonempty_list(PATHSEP,type_path_segment) // lookahead token is inherited
                                                                                                        type_path_segment . 

** In state 99, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path_segment 
path_ident_segment option(path_gen_path_fn) 
                   path_gen_path_fn 
                   option(PATHSEP) type_path_fn 
                                   LPAREN option(type_path_fn_inputs) RPAREN option(rarrow_no_bounds) 
                                                                             rarrow_no_bounds 
                                                                             RARROW type_no_bounds 
                                                                                    qualified_path_in_type 
                                                                                    qualified_path_type separated_nonempty_list(PATHSEP,type_path_segment) 
                                                                                                        type_path_segment . PATHSEP separated_nonempty_list(PATHSEP,type_path_segment) 

** Conflict (reduce/reduce) in state 88.
** Tokens involved: RAW_IDENT IDENT
** The following explanations concentrate on token RAW_IDENT.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT FOR LT list(outer_attr) CONST ident COLON type_param_bound PLUS

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               trait_bound 
                               option(question_or_for) type_path 
                               for_lifetimes 
                               FOR generic_params 
                                   LT separated_nonempty_list(COMMA,generic_param) GT 
                                      generic_param 
                                      list(outer_attr) const_param 
                                                       (?)

** In state 88, looking ahead at RAW_IDENT, reducing production
** nonempty_list(terminated(type_param_bound,PLUS)) -> type_param_bound PLUS
** is permitted because of the following sub-derivation:

CONST ident COLON typ option(const_param_body) // lookahead token appears because option(const_param_body) can begin with RAW_IDENT
                  trait_object_type // lookahead token is inherited
                  type_param_bounds // lookahead token is inherited
                  nonempty_separated_or_terminated_list(PLUS,type_param_bound) // lookahead token is inherited
                  nonempty_list(terminated(type_param_bound,PLUS)) // lookahead token is inherited
                  type_param_bound PLUS . 

** In state 88, looking ahead at RAW_IDENT, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

CONST ident COLON typ option(const_param_body) 
                  trait_object_type 
                  type_param_bounds 
                  nonempty_separated_or_terminated_list(PLUS,type_param_bound) 
                  nonempty_list(terminated(type_param_bound,PLUS)) 
                  type_param_bound PLUS nonempty_list(terminated(type_param_bound,PLUS)) 
                                        type_param_bound PLUS 
                                        trait_bound 
                                        option(question_or_for) type_path // lookahead token appears because type_path can begin with RAW_IDENT
                                        . 

** Conflict (shift/reduce) in state 83.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT FOR LT list(outer_attr) CONST ident COLON

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               trait_bound 
                               option(question_or_for) type_path 
                               for_lifetimes 
                               FOR generic_params 
                                   LT separated_nonempty_list(COMMA,generic_param) GT 
                                      generic_param 
                                      list(outer_attr) const_param 
                                                       CONST ident COLON typ option(const_param_body) 
                                                                         type_no_bounds 
                                                                         (?)

** In state 83, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) 
. PATHSEP 

** In state 83, looking ahead at PATHSEP, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

trait_bound 
option(question_or_for) type_path // lookahead token appears because type_path can begin with PATHSEP
. 

** Conflict (shift/reduce) in state 72.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT LBRACK

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               LBRACK typ SEMI expression RBRACK 
                                      type_no_bounds 
                                      (?)

** In state 72, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) 
. PATHSEP 

** In state 72, looking ahead at PATHSEP, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

trait_bound 
option(question_or_for) type_path // lookahead token appears because type_path can begin with PATHSEP
. 

** Conflict (shift/reduce) in state 71.
** Tokens involved: SUPER SELFVALUE SELFTYPE RPAREN RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT LPAREN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               (?)

** In state 71, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

LPAREN typ RPAREN 
       type_no_bounds 
       type_path 
       option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) 
       . PATHSEP 

** In state 71, looking ahead at PATHSEP, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

trait_bound 
LPAREN option(question_or_for) type_path RPAREN // lookahead token appears because type_path can begin with PATHSEP
       . 

** Conflict (shift/reduce) in state 52.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               (?)

** In state 52, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) 
. PATHSEP 

** In state 52, looking ahead at PATHSEP, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

trait_bound 
option(question_or_for) type_path // lookahead token appears because type_path can begin with PATHSEP
. 

** Conflict (shift/reduce) in state 49.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LT STAR MUT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            path_expression 
                            qualified_path_in_expression 
                            qualified_path_type separated_nonempty_list(PATHSEP,path_expr_segment) 
                            LT typ option(as_typath) GT 
                               type_no_bounds 
                               raw_pointer_type 
                               STAR MUT type_no_bounds 
                                        (?)

** In state 49, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) 
. PATHSEP 

** In state 49, looking ahead at PATHSEP, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

trait_bound 
option(question_or_for) type_path // lookahead token appears because type_path can begin with PATHSEP
. 

** Conflict (shift/reduce) in state 46.
** Tokens involved: SUPER SELFVALUE SELFTYPE RAW_IDENT PATHSEP IDENT DOLLAR_CRATE CRATE
** The following explanations concentrate on token PATHSEP.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR option(closure_params) OR RARROW

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                                                         RARROW type_no_bounds block_expression 
                                                                (?)

** In state 46, looking ahead at PATHSEP, shifting is permitted
** because of the following sub-derivation:

type_path 
option(PATHSEP) separated_nonempty_list(PATHSEP,type_path_segment) 
. PATHSEP 

** In state 46, looking ahead at PATHSEP, reducing production
** option(question_or_for) ->
** is permitted because of the following sub-derivation:

trait_bound 
option(question_or_for) type_path // lookahead token appears because type_path can begin with PATHSEP
. 

** Conflict (shift/reduce) in state 45.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ OR option(closure_params) OR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            closure_expression 
                            OR option(closure_params) OR expr_or_typ_block 
                                                         expression 
                                                         exprs_with_block 
                                                         (?)

** In state 45, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 45, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 38.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ RAW_CONST

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            RAW_CONST expression 
                                      exprs_with_block 
                                      (?)

** In state 38, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 38, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 36.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ RAW_MUT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            RAW_MUT expression 
                                    exprs_with_block 
                                    (?)

** In state 36, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 36, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 34.
** Tokens involved: STAR OR MINUS LT LPAREN LBRACK LBRACE DOTDOTEQ DOTDOT AND
** The following explanations concentrate on token LBRACE.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ RETURN

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            return_expression 
                            RETURN option(expression) 
                                   expression 
                                   exprs_with_block 
                                   (?)

** In state 34, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 34, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 33.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ STAR

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_without_block 
                            operator_expression 
                            STAR expression 
                                 exprs_with_block 
                                 (?)

** In state 33, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 33, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce/reduce) in state 29.
** Tokens involved: WHILE UNSAFE UNDERSCORE TRUE SUPER STRING_LIT STAR SELFVALUE SELFTYPE RETURN RBRACE RAW_STRING_LIT RAW_MUT RAW_IDENT RAW_C_STRING RAW_CONST RAW_BYTE_STRING POUND PATHSEP OR NOT MOVE MINUS MATCH LT LPAREN LOOP LIFETIME_OR_LABEL LBRACK LBRACE INT_LIT IF IDENT FOR FLOAT_LIT FALSE DOTDOTEQ DOTDOT DOLLAR_CRATE C_STRING CRATE CONTINUE CONST CHAR_LIT BYTE_STRING BYTE BREAK ASYNC AND AMPMUT
** The following explanations concentrate on token LBRACE.
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACE list(inner_attr)

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            block_expression 
                            LBRACE list(inner_attr) option(statements) RBRACE 
                                                    statements 
                                                    (?)

** In state 29, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

list(statement) 
statement list(statement) 
expression_statement 
exprs_with_block option(SEMI) 
block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 29, looking ahead at LBRACE, reducing production
** list(statement) ->
** is permitted because of the following sub-derivation:

list(statement) exprs_without_block // lookahead token appears because exprs_without_block can begin with LBRACE
. 

** In state 29, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

list(statement) 
statement list(statement) 
expression_statement 
exprs_with_block option(SEMI) 
loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 

** Conflict (shift/reduce) in state 8.
** Token involved: POUND
** This state is reached from program after reading:

POUND LBRACK simple_path EQ LBRACE

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            block_expression 
                            (?)

** In state 8, looking ahead at POUND, shifting is permitted
** because of the following sub-derivation:

LBRACE list(inner_attr) option(statements) RBRACE 
       inner_attr list(inner_attr) 
       . POUND NOT LBRACK attr RBRACK 

** In state 8, looking ahead at POUND, reducing production
** list(inner_attr) ->
** is permitted because of the following sub-derivation:

LBRACE list(inner_attr) option(statements) RBRACE // lookahead token appears because option(statements) can begin with POUND
       . 

** Conflict (shift/reduce) in state 6.
** Token involved: LBRACE
** This state is reached from program after reading:

POUND LBRACK simple_path EQ

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
items EOF 
item items 
list(outer_attr) vis_item 
outer_attr list(outer_attr) 
POUND LBRACK attr RBRACK 
             simple_path maybe_attr_input 
                         attr_input 
                         EQ expression 
                            exprs_with_block 
                            (?)

** In state 6, looking ahead at LBRACE, shifting is permitted
** because of the following sub-derivation:

block_expression 
. LBRACE list(inner_attr) option(statements) RBRACE 

** In state 6, looking ahead at LBRACE, reducing production
** option(loop_label) ->
** is permitted because of the following sub-derivation:

loop_expression 
option(loop_label) loop_switch // lookahead token appears because loop_switch can begin with LBRACE
. 
